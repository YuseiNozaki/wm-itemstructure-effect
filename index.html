<!DOCTYPE html>
<html>
<head>
  <title>visual search task</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://unpkg.com/jspsych@7"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-instructions@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1"></script>
  <link href="https://unpkg.com/jspsych@7/css/jspsych.css" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Create required DOM elements for cognition.run deployment
    const targetDiv = document.createElement('div');
    targetDiv.id = 'jspsych-target';
    document.body.appendChild(targetDiv);

    const canvas = document.createElement('canvas');
    canvas.id = 'jspsych-visual-search-canvas';
    canvas.classList.add('hidden');
    document.body.appendChild(canvas);

    const searchWindowDiv = document.createElement('div');
    searchWindowDiv.id = 'search-window';
    searchWindowDiv.classList.add('hidden');
    document.body.appendChild(searchWindowDiv);

    // Initialize jsPsych v7 instance (upgraded from v6.3.1)
    // Note: Targeting v7.x as the latest stable version (v8.x may not be available yet)
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: function() {
        jsPsych.data.displayData();
      },
      on_trial_start: function() {
        // å„è©¦è¡Œã®é–‹å§‹æ™‚ã«ã€å®Ÿé¨“ãŒãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
        if (!document.fullscreenElement && 
            !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && 
            !document.msFullscreenElement) {
          // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã§ã¯ãªã„å ´åˆã€å†åº¦è¦æ±‚ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚ˆã£ã¦ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦ï¼‰
          console.log("ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã®å†ç¢ºèª");
        }
      }
    });

    // Automatically capture participant's screen resolution
    jsPsych.data.addProperties({
      screen_width: window.screen.width,
      screen_height: window.screen.height
    });

    // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‚’è¦æ±‚ã™ã‚‹é–¢æ•°
    function enterFullscreen() {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen().then(() => {
          console.log("ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«æ­£å¸¸ã«ç§»è¡Œã—ã¾ã—ãŸ");
        }).catch(err => {
          console.warn("ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ç§»è¡Œã‚¨ãƒ©ãƒ¼:", err);
        });
      } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      }
      
      // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç®¡ç†ã‚’æ”¹å–„ - ãƒ•ã‚©ãƒ¼ãƒ ã®é‚ªé­”ã‚’ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
      // setTimeout(() => {
      //   if (document.getElementById('jspsych-target')) {
      //     document.getElementById('jspsych-target').focus();
      //   }
      // }, 100);
    }

    // å®Ÿé¨“é–‹å§‹æ™‚ã«ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«è‡ªå‹•çš„ã«ç§»è¡Œã™ã‚‹ã‚ˆã†è¨­å®š
    // ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ã®ãŸã‚ã€ä½•ã‚‰ã‹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œï¼ˆã‚­ãƒ¼å…¥åŠ›ãªã©ï¼‰ã«å¿œã˜ã¦å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹

    // ãƒ–ãƒ©ã‚¦ã‚¶ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ‡ãƒãƒƒã‚°é–¢æ•° (å‰Šé™¤æ¸ˆã¿ - ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç«¶åˆã‚’é¿ã‘ã‚‹ãŸã‚)
    // function testBrowserInteraction() {
    //   console.log("ãƒ–ãƒ©ã‚¦ã‚¶ãƒ†ã‚¹ãƒˆ: ã‚­ãƒ¼å…¥åŠ›ã®ãƒ†ã‚¹ãƒˆ");
    //   
    //   // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã®ãƒ†ã‚¹ãƒˆ
    //   window.addEventListener('keydown', function(e) {
    //     console.log("ã‚­ãƒ¼å…¥åŠ›ã‚’æ¤œå‡º:", e.key);
    //   });
    //   
    //   // ã‚«ãƒ¼ã‚½ãƒ«æ“ä½œã®ãƒ†ã‚¹ãƒˆ
    //   document.addEventListener('mousemove', function(e) {
    //     // å¤§é‡ã®ãƒ­ã‚°ã‚’é¿ã‘ã‚‹ãŸã‚ã€100pxç§»å‹•ã”ã¨ã«ãƒ­ã‚°
    //     if (e.clientX % 100 < 5 && e.clientY % 100 < 5) {
    //       console.log("ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®:", e.clientX, e.clientY);
    //     }
    //   });
    //   
    //   console.log("ãƒ–ãƒ©ã‚¦ã‚¶ãƒ†ã‚¹ãƒˆ: ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã®çŠ¶æ…‹");
    //   if (document.fullscreenElement || 
    //       document.webkitFullscreenElement || 
    //       document.mozFullScreenElement || 
    //       document.msFullscreenElement) {
    //     console.log("ç¾åœ¨ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰");
    //   } else {
    //     console.log("ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ã¯ãªã„");
    //   }
    // }
    
    // å®Ÿé¨“é–‹å§‹æ™‚ã«ãƒ†ã‚¹ãƒˆé–¢æ•°ã‚’å®Ÿè¡Œ (å‰Šé™¤æ¸ˆã¿)
    // window.addEventListener('load', function() {
    //   setTimeout(testBrowserInteraction, 2000);
    // });

    // Fullscreen management - only add listeners when needed to avoid conflicts with forms
    let fullscreenListenersActive = false;
    
    function addFullscreenListeners() {
      if (!fullscreenListenersActive) {
        // Add a small delay to ensure DOM is ready
        setTimeout(() => {
          document.addEventListener('fullscreenchange', handleFullscreenChange);
          document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
          document.addEventListener('mozfullscreenchange', handleFullscreenChange);
          document.addEventListener('MSFullscreenChange', handleFullscreenChange);
          fullscreenListenersActive = true;
        }, 50);
      }
    }
    
    function removeFullscreenListeners() {
      if (fullscreenListenersActive) {
        document.removeEventListener('fullscreenchange', handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
        document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
        fullscreenListenersActive = false;
      }
    }

    function handleFullscreenChange() {
      try {
        if (document.fullscreenElement || 
            document.webkitFullscreenElement || 
            document.mozFullScreenElement || 
            document.msFullscreenElement) {
          console.log("ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ã‚ã‚Šã¾ã—ãŸ");
        } else {
          console.log("ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ã‹ã‚‰æŠœã‘ã¾ã—ãŸ");
        }
      } catch (error) {
        console.warn("ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³çŠ¶æ…‹ã®ç¢ºèªä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
      }
    }

    // Experiment parameters
    const params = {
      // Screen dimensions (will be updated at runtime)
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      
      // Window dimensions (approximately 1/9 of screen)
      windowWidth: Math.floor(window.innerWidth / 3),
      windowHeight: Math.floor(window.innerHeight / 3),
      
      // Objects
      numObjects: 25, // Total number of objects per trial
      objectSize: 40, // Fixed size for all objects
      
      // Target detection tolerance
      targetTolerance: 0.8, // Additional tolerance as multiplier of object size (0.8 = 80% of object size)
      
      // Colors and shapes
      colors: ['red', 'blue', 'green', 'yellow', 'purple'],
      shapes: ['circle', 'triangle', 'square', 'diamond'],
      
      // Trials
      trialsPerCondition: 10,
      
      // Memory task
      memoryGridSize: 4, // 4x4 grid
      memoryPositions: 3, // Number of positions to remember
    };

    // Generate random object size within the specified range
    // Get fixed object size (all objects use the same size defined in params.objectSize)
    // All objects are consistently 40px in size
    function getObjectSize() {
      return params.objectSize;
    }

    // Get a representative size for target presentation (same as search objects)
    function getTargetPresentationSize() {
      return params.objectSize; // Same as search objects - 40px
    }

    // Trial factors
    const factors = {
      viewCondition: ['window', 'scroll', 'fullscreen'],
      structure: ['structured', 'unstructured'],
      memoryLoad: ['with-memory', 'without-memory']
    };

    // Track mouse movements
    let mouseX = 0;
    let mouseY = 0;
    let mousePath = [];
    let totalMovement = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let isMouseDown = false;
    let currentDragDistance = 0; // Track drag distance for current interaction
    let justFinishedDrag = false; // Track if a drag operation just finished
    let dragOffsetX = 0; // Offset between cursor and window left edge when drag starts
    let dragOffsetY = 0; // Offset between cursor and window top edge when drag starts

    // Target and distractor objects
    let objects = [];
    let targetObject = null;

    // Memory task variables
    let memoryPositions = [];
    let selectedMemoryPositions = [];

    // Trial progress tracking variables
    let currentMainTrialNumber = 0;
    const totalMainTrials = 120; // 3 viewConditions Ã— 2 structures Ã— 10 trialsPerCondition Ã— 2 blocks

    // Welcome screen
    const welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<h1>å®Ÿé¨“ã«å‚åŠ ã—ã¦ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚</h1>' +
                '<p>ä¸‹ã®ã€Œæ¬¡ã¸ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å®Ÿé¨“ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>' +
                '<div style="margin: 20px 0;">' +
                '<button id="welcome-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">æ¬¡ã¸</button>' +
                '</div>',
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during welcome
        removeFullscreenListeners();
        
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('welcome-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Informed consent screen
    const informedConsent = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; font-size: 14px;">';
        html += '<h1 style="text-align: center; color: #333; margin-bottom: 30px;">ç ”ç©¶ã«é–¢ã™ã‚‹åŒæ„äº‹é …</h1>';
        
        // Scrollable content area
        html += '<div id="consent-content" style="max-height: 500px; overflow-y: auto; border: 1px solid #ddd; padding: 20px; margin-bottom: 20px; background-color: #f9f9f9; text-align: left;">';
        
        html += '<h3>1. ç ”ç©¶ã®ç›®çš„</h3>';
        html += '<p>æœ¬ç ”ç©¶ã¯ã€åˆ¶é™ã•ã‚ŒãŸè¦–é‡ã‚’ç§»å‹•ã—ã¦è¡Œã†è¦–è¦šæ¢ç´¢å ´é¢ã«ãŠã„ã¦ã€è¦–è¦šçš„ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªãŠã‚ˆã³ç‰©ä½“ã®é…ç½®æ§‹é€ ãŒæ¢ç´¢åŠ¹ç‡ã«ä¸ãˆã‚‹å½±éŸ¿ã‚’è§£æ˜ã™ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã—ã¾ã™ã€‚</p>';
        
        html += '<h3>2. å®Ÿé¨“å†…å®¹</h3>';
        html += '<ul>';
        html += '<li>å®Ÿæ–½å ´æ‰€ï¼šå®Ÿé¨“ã«é›†ä¸­ã§ãã‚‹ç’°å¢ƒï¼ˆZoom ã§ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’è¡Œã„ã¾ã™ï¼‰</li>';
        html += '<li>æ‰€è¦æ™‚é–“ï¼šç´„ 30 åˆ†ï¼ˆèª¬æ˜ç­‰ã‚’å«ã‚€ï¼‰</li>';
        html += '<li>èª²é¡Œå†…å®¹ï¼šã”è‡ªèº«ã® PC ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ãŸã ãã€ç”»é¢ä¸Šã«è¡¨ç¤ºã•ã‚Œã‚‹ç‰¹å®šã®å›³å½¢ã®å ´æ‰€ã‚’æ¢ã™èª²é¡Œã«ã€ç¹°ã‚Šè¿”ã—å–ã‚Šçµ„ã‚“ã§ã„ãŸã ãã¾ã™ã€‚</li>';
        html += '<li>åé›†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ï¼šæ°åã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆè¬ç¤¼æ”¯æ‰•ã„ç›®çš„ã®ã¿ï¼‰ã€æ€§åˆ¥ã€å¹´é½¢ã€åå¿œæ™‚é–“ã€èª²é¡Œã®æˆç¸¾ã€ã‚«ãƒ¼ã‚½ãƒ«ã®ç§»å‹•å±¥æ­´</li>';
        html += '</ul>';
        
        html += '<h3>3. å‚åŠ æ¡ä»¶</h3>';
        html += '<ul>';
        html += '<li>18 æ­³ä»¥ä¸Šã®æ–¹ã€‚</li>';
        html += '<li>æ­£å¸¸ã¾ãŸã¯çŸ¯æ­£è¦–åŠ›ã‚’æœ‰ã—ã€èª²é¡Œã®ç†è§£ã«æ”¯éšœãŒãªã„æ–¹ã€‚</li>';
        html += '<li>é™ã‹ã§è½ã¡ç€ã„ãŸå ´æ‰€ã‹ã‚‰è‡ªèº«ã®ãƒ‘ã‚½ã‚³ãƒ³ã‚’ä½¿ã£ã¦ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§å®Ÿé¨“ã«å‚åŠ ã§ãã‚‹æ–¹ã€‚</li>';
        html += '</ul>';
        
        html += '<h3>4. äºˆæƒ³ã•ã‚Œã‚‹ä¸åˆ©ç›Šãƒ»ãƒªã‚¹ã‚¯ã¨å¯¾å‡¦</h3>';
        html += '<ul>';
        html += '<li>ç”»é¢æ³¨è¦–ã«ã‚ˆã‚‹ç›®ã®ç–²ã‚Œã€ã‚¹ãƒˆãƒ¬ã‚¹ç­‰ãŒç”Ÿã˜ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</li>';
        html += '<li>ä¸å¿«ãƒ»ä½“èª¿ä¸è‰¯æ™‚ã¯ã„ã¤ã§ã‚‚ä¸­æ–­ãƒ»ä¸­æ­¢ã§ãã¾ã™ã€‚</li>';
        html += '</ul>';
        
        html += '<h3>5. ç ”ç©¶æˆæœã®å…¬é–‹</h3>';
        html += '<p>ã“ã®ç ”ç©¶ã®æˆæœã¯ã€åšå£«è«–æ–‡ãŠã‚ˆã³å¿ƒç†ç³»ã®å­¦ä¼šã§ç™ºè¡¨ã‚’è¡Œã†äºˆå®šã§ã™ã€‚ãã®éš›ã«åé›†ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å…¬é–‹ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€æƒ…å ±ã‹ã‚‰å€‹äººãŒç‰¹å®šã•ã‚Œãªã„å½¢å¼ã§ã®å…¬é–‹ã‚’è¡Œã„ã¾ã™ã€‚</p>';
        
        html += '<h3>6. è¬ç¤¼ãƒ»è²»ç”¨</h3>';
        html += '<ul>';
        html += '<li>è¬ç¤¼ã¨ã—ã¦ã€PayPayãªã©ã«äº¤æ›å¯èƒ½ãªãƒ‡ã‚¸ã‚¿ãƒ«ã‚®ãƒ•ãƒˆã€Œãƒ‡ã‚¸ã‚³ã€ã‚’ 300 å††åˆ†ãŠæ”¯æ‰•ã„ã„ãŸã—ã¾ã™ã€‚</li>';
        html += '<li>ã€Œãƒ‡ã‚¸ã‚³ã€ã®ãŠæ”¯æ‰•ã„ã«å¿…è¦ãªãŸã‚ã€æ°åã¨ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã”å›ç­”ã„ãŸã ãã¾ã™ã€‚</li>';
        html += '<li>å‚åŠ ã«è²»ç”¨ã¯ã‹ã‹ã‚Šã¾ã›ã‚“ï¼ˆé€šä¿¡è²»ç­‰ã¯å‚åŠ è€…è² æ‹…ã¨ãªã‚Šã¾ã™ï¼‰ã€‚</li>';
        html += '</ul>';
        
        html += '<h3>7. ä»»æ„å‚åŠ ãƒ»æ’¤å›ã®è‡ªç”±</h3>';
        html += '<ul>';
        html += '<li>å‚åŠ ã¯å®Œå…¨ã«ä»»æ„ã§ã™ã€‚ã¾ãŸç†ç”±ã‚’å•ã‚ãšã€é€”ä¸­ã§æ’¤å›ã§ãã¾ã™ã€‚</li>';
        html += '<li>å‚åŠ ã‚’æ’¤å›ã—ãŸå ´åˆã‚„é€”ä¸­ã§ä¸­æ­¢ã¨ã—ãŸå ´åˆã«ã‚‚ã€ä¸åˆ©ç›Šã¯ä¸€åˆ‡ã‚ã‚Šã¾ã›ã‚“ã€‚</li>';
        html += '</ul>';
        
        html += '<h3>8. å€‹äººæƒ…å ±ã¨ãƒ‡ãƒ¼ã‚¿ã®å–æ‰±ã„</h3>';
        html += '<ul>';
        html += '<li>ãƒ‡ãƒ¼ã‚¿ã¯ ID ã§ç®¡ç†ã—ã€æ°åç­‰ã®è­˜åˆ¥æƒ…å ±ã¨åˆ†é›¢ã—ã¦ä¿ç®¡ã—ã¾ã™ã€‚</li>';
        html += '<li>ãƒ‡ãƒ¼ã‚¿ã¯ç ”ç©¶å®Ÿæ–½è€…ãŠã‚ˆã³æŒ‡å°æ•™å“¡ã®ã¿ãŒé–²è¦§å¯èƒ½ãªçŠ¶æ…‹ã§ä¿å­˜ã—ã¾ã™ã€‚</li>';
        html += '<li>ãƒ‡ãƒ¼ã‚¿ã®ç¬¬ä¸‰è€…æä¾›ã¯åŸå‰‡è¡Œã„ã¾ã›ã‚“ã€‚å­¦ä¼šãƒ»è«–æ–‡ç­‰ã§ã¯çµ±è¨ˆçš„ã«é›†è¨ˆã—ãŸå½¢ã§å…¬è¡¨ã—ã¾ã™ã€‚</li>';
        html += '<li>å®Ÿé¨“å®Ÿæ–½ä¸Šã§å¾—ã‚‰ã‚ŒãŸå€‹äººæƒ…å ±ç­‰ã¯ã€ã™ã¹ã¦å®ˆç§˜ã‚’ãŠç´„æŸã—ã€å¤–éƒ¨ã‹ã‚‰é–²è¦§ä¸å¯ã®çŠ¶æ…‹ã§å³é‡ã«ç®¡ç†ã„ãŸã—ã¾ã™ã€‚</li>';
        html += '</ul>';
        
        html += '<h3>9. ãŠå•ã„åˆã‚ã›å…ˆ</h3>';
        html += '<p><strong>ç ”ç©¶å®Ÿæ–½è€…ï¼š</strong>é‡ï¨‘ å„ªæ™´ï¼ˆæ±äº¬å­¦èŠ¸å¤§å­¦å¤§å­¦é™¢ é€£åˆå­¦æ ¡æ•™è‚²å­¦ç ”ç©¶ç§‘ åšå£«èª²ç¨‹ï¼‰<br>';
        html += 'E-mailï¼šr241004y@st.u-gakugei.ac.jp</p>';
        html += '<p><strong>æŒ‡å°æ•™å“¡ï¼š</strong>é–¢å£ è²´è£•ï¼ˆæ±äº¬å­¦èŠ¸å¤§å­¦ æ•™è‚²å¿ƒç†å­¦è¬›åº§ æ•™æˆï¼‰<br>';
        html += 'E-mailï¼šsekiguti@u-gakugei.ac.jp</p>';
        
        html += '</div>'; // End of scrollable content
        
        // Consent checkbox and button
        html += '<div style="text-align: center; margin: 20px 0;">';
        html += '<label style="display: flex; align-items: center; justify-content: center; font-size: 16px; margin-bottom: 20px;">';
        html += '<input type="checkbox" id="consent-checkbox" style="margin-right: 10px; transform: scale(1.2);"> ';
        html += 'ä¸Šè¨˜ã®å†…å®¹ã‚’ç¢ºèªã—ã€ç ”ç©¶å‚åŠ ã«åŒæ„ã—ã¾ã™';
        html += '</label>';
        html += '<button id="consent-next-btn" disabled style="padding: 12px 24px; font-size: 16px; background-color: #ccc; color: #666; border: none; border-radius: 5px; cursor: not-allowed; transition: all 0.3s;">æ¬¡ã¸é€²ã‚€</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during consent
        removeFullscreenListeners();
        
        const checkbox = document.getElementById('consent-checkbox');
        const nextBtn = document.getElementById('consent-next-btn');
        
        // Enable/disable button based on checkbox state
        checkbox.addEventListener('change', function() {
          if (checkbox.checked) {
            nextBtn.disabled = false;
            nextBtn.style.backgroundColor = '#007bff';
            nextBtn.style.color = 'white';
            nextBtn.style.cursor = 'pointer';
          } else {
            nextBtn.disabled = true;
            nextBtn.style.backgroundColor = '#ccc';
            nextBtn.style.color = '#666';
            nextBtn.style.cursor = 'not-allowed';
          }
        });
        
        // Add click event listener to the Next button
        nextBtn.addEventListener('click', function() {
          if (checkbox.checked) {
            // Record consent in jsPsych data
            jsPsych.data.addProperties({
              informed_consent: true,
              consent_timestamp: new Date().toISOString()
            });
            jsPsych.finishTrial();
          }
        });
      }
    };

    // Combined demographic information - Name, Email, Age, and Gender
    const demographics = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 700px; margin: 0 auto; padding: 20px; text-align: center; font-family: \'Noto Sans JP\', \'ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro\', \'Hiragino Kaku Gothic Pro\', \'ãƒ¡ã‚¤ãƒªã‚ª\', Meiryo, sans-serif;">';
        html += '<h2 style="margin-bottom: 30px; color: #333;">åŸºæœ¬æƒ…å ±ã®å…¥åŠ›</h2>';
        
        // Information about data usage
        html += '<div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin-bottom: 30px; text-align: left; line-height: 1.6;">';
        html += '<h4 style="color: #495057; margin-top: 0; margin-bottom: 15px;">å€‹äººæƒ…å ±ã®å–ã‚Šæ‰±ã„ã«ã¤ã„ã¦</h4>';
        html += '<ul style="margin: 0; padding-left: 20px; color: #6c757d;">';
        html += '<li style="margin-bottom: 8px;"><strong>æ°åãƒ»ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</strong>ã¯è¬ç¤¼ã®ãŠæ”¯æ‰•ã„ç›®çš„ã®ã¿ã«åˆ©ç”¨ã—ã€å®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ã¨ã¯åˆ†é›¢ã—ã¦ç®¡ç†ã„ãŸã—ã¾ã™ã€‚</li>';
        html += '<li style="margin-bottom: 0;">è¬ç¤¼ã®ãŠæ”¯æ‰•ã„ã®ãŸã‚ã€å…¥åŠ›ã„ãŸã ã„ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¾Œæ—¥ã”é€£çµ¡ã„ãŸã—ã¾ã™ã€‚</li>';
        html += '</ul>';
        html += '</div>';
        
        html += '<form id="demographics-form" style="margin: 20px 0;">';
        
        // Name field
        html += '<div style="margin: 20px 0; text-align: left;">';
        html += '<label for="name-input" style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: bold;">æ°å <span style="color: #dc3545;">*</span></label>';
        html += '<input type="text" id="name-input" name="name" required style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box;" placeholder="ãŠåå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„">';
        html += '</div>';
        
        // Email field
        html += '<div style="margin: 20px 0; text-align: left;">';
        html += '<label for="email-input" style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: bold;">ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ <span style="color: #dc3545;">*</span></label>';
        html += '<input type="email" id="email-input" name="email" required style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box;" placeholder="example@example.com">';
        html += '<small style="color: #6c757d; font-size: 14px; display: block; margin-top: 5px;">r241004y@st.u-gakugei.ac.jp ã‹ã‚‰ã®é€£çµ¡ã‚’å—ä¿¡ã§ãã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã”å…¥åŠ›ãã ã•ã„</small>';
        html += '</div>';
        
        // Age field
        html += '<div style="margin: 20px 0; text-align: left;">';
        html += '<label for="age-select" style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: bold;">å¹´é½¢ <span style="color: #dc3545;">*</span></label>';
        html += '<select id="age-select" name="age" required style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box;">';
        html += '<option value="">é¸æŠã—ã¦ãã ã•ã„</option>';

        // Generate age options from 18 to 100
        for (let i = 18; i <= 100; i++) {
          html += `<option value="${i}">${i}</option>`;
        }
        
        html += '</select>';
        html += '</div>';
        
        // Gender field
        html += '<div style="margin: 20px 0; text-align: left;">';
        html += '<label for="gender-select" style="display: block; margin-bottom: 10px; font-size: 16px; font-weight: bold;">æ€§åˆ¥ <span style="color: #dc3545;">*</span></label>';
        html += '<select id="gender-select" name="gender" required style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ccc; border-radius: 5px; box-sizing: border-box;">';
        html += '<option value="">é¸æŠã—ã¦ãã ã•ã„</option>';
        html += '<option value="ç”·æ€§">ç”·æ€§</option>';
        html += '<option value="å¥³æ€§">å¥³æ€§</option>';
        html += '<option value="ãã®ä»–">ãã®ä»–</option>';
        html += '</select>';
        html += '</div>';
        
        html += '<div style="margin: 30px 0; text-align: center;">';
        html += '<button type="submit" style="padding: 12px 30px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">æ¬¡ã¸é€²ã‚€</button>';
        html += '</div>';
        html += '</form>';
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during demographics
        removeFullscreenListeners();
        
        const form = document.getElementById('demographics-form');
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          
          const nameInput = document.getElementById('name-input');
          const emailInput = document.getElementById('email-input');
          const ageSelect = document.getElementById('age-select');
          const genderSelect = document.getElementById('gender-select');
          
          const name = nameInput.value.trim();
          const email = emailInput.value.trim();
          const age = ageSelect.value;
          const gender = genderSelect.value;
          
          // Validate all fields
          if (!name) {
            alert('æ°åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
            nameInput.focus();
            return;
          }
          
          if (!email) {
            alert('ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
            emailInput.focus();
            return;
          }
          
          // Basic email validation
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(email)) {
            alert('æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
            emailInput.focus();
            return;
          }
          
          if (!age) {
            alert('å¹´é½¢ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
            ageSelect.focus();
            return;
          }
          
          if (!gender) {
            alert('æ€§åˆ¥ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
            genderSelect.focus();
            return;
          }
          
          // Store all demographic data
          jsPsych.data.addProperties({
            participant_name: name,
            participant_email: email,
            age: age,
            gender: gender
          });
          
          // Finish the trial with the collected data
          jsPsych.finishTrial({
            participant_name: name,
            participant_email: email,
            age: age,
            gender: gender
          });
        });
      },
      on_finish: function() {
        // After demographics are complete, activate fullscreen
        setTimeout(() => {
          addFullscreenListeners();
          enterFullscreen();
        }, 100);
      }
    };

    // Initial explanation for memory-first group (å‰åŠãŒè¨˜æ†¶èª²é¡Œã‚°ãƒ«ãƒ¼ãƒ—)
    const initialExplanationMemoryFirst = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 900px; margin: 0 auto; padding: 40px; font-family: \'Noto Sans JP\', \'ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro\', \'Hiragino Kaku Gothic Pro\', \'ãƒ¡ã‚¤ãƒªã‚ª\', Meiryo, sans-serif; line-height: 1.8; background-color: #ffffff;">';
        
        // Title
        html += '<h1 style="text-align: center; color: #2c3e50; margin-bottom: 40px; font-size: 28px; font-weight: bold;">ãƒ«ãƒ¼ãƒ«èª¬æ˜</h1>';
        
        // Memory task explanation with image
        html += '<div style="background-color: #fff3cd; border: 2px solid #ffeaa7; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h2 style="color: #856404; margin-top: 0; font-size: 20px;">è¨˜æ†¶èª²é¡Œã«ã¤ã„ã¦</h2>';
        html += '<div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 300px;">';
        html += '<p style="font-size: 16px; margin: 10px 0;">ã¾ãšã€4Ã—4ã®ã‚°ãƒªãƒƒãƒ‰ã«è‰²ã®ã¤ã„ãŸã‚»ãƒ«ãŒ3ç§’é–“è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ãã®ä½ç½®ã‚’è¦šãˆã¦ãã ã•ã„ã€‚</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/7_è¨˜æ†¶èª²é¡Œ_å‘ˆç¤º.png" alt="è¨˜æ†¶èª²é¡Œã®è¡¨ç¤ºä¾‹" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Target presentation with image
        html += '<div style="background-color: #d1ecf1; border: 2px solid #bee5eb; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h2 style="color: #0c5460; margin-top: 0; font-size: 20px;">ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢ã®ç¢ºèª</h2>';
        html += '<div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 300px;">';
        html += '<p style="font-size: 16px; margin: 10px 0;">æ¬¡ã«ã€æ¢ã™å›³å½¢ãŒ1ç§’é–“è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚è‰²ã¨å½¢ã‚’ã—ã£ã‹ã‚Šè¦šãˆã¦ãã ã•ã„ã€‚</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/1_ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå‘ˆç¤º.png" alt="ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢ã®è¡¨ç¤ºä¾‹" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';

        // 3 viewing conditions
        html += '<div style="margin-bottom: 25px;">';
        html += '<h2 style="color: #dc3545; font-size: 20px; margin-bottom: 15px;">3ã¤ã®è¡¨ç¤ºæ¡ä»¶</h2>';
        
        // Fullscreen condition
        html += '<div style="background-color: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 15px; margin-bottom: 15px;">';
        html += '<h3 style="color: #1976d2; margin: 0 0 15px 0; font-size: 18px;">ğŸ–¥ï¸ å…¨ç”»é¢æ¡ä»¶</h3>';
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 250px;">';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>è¡¨ç¤ºï¼š</strong> ç”»é¢å…¨ä½“ã«å›³å½¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>æ“ä½œï¼š</strong> è‡ªç”±ã«ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã—ã¦å›³å½¢ã‚’æ¢ã—ã¾ã™</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/2_å…¨ç”»é¢.png" alt="å…¨ç”»é¢æ¡ä»¶ã®ä¾‹" style="max-width: 180px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Window condition
        html += '<div style="background-color: #fff3e0; border: 2px solid #ff9800; border-radius: 8px; padding: 15px; margin-bottom: 15px;">';
        html += '<h3 style="color: #f57c00; margin: 0 0 15px 0; font-size: 18px;">ğŸªŸ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¡ä»¶</h3>';
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 250px;">';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>è¡¨ç¤ºï¼š</strong> å°ã•ãªçª“ã‹ã‚‰å›³å½¢ã‚’è¦³å¯Ÿã—ã¾ã™</p>';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>æ“ä½œï¼š</strong> ãƒã‚¦ã‚¹ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦çª“ã‚’ç§»å‹•ã•ã›ãªãŒã‚‰æ¢ã—ã¾ã™</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto; display: flex; gap: 10px;">';
        html += '<img src="screen_shots/3_ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦_ã¯ã˜ã‚.png" alt="ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¡ä»¶ï¼ˆåˆæœŸï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '<img src="screen_shots/4_ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦_ç§»å‹•å¾Œ.png" alt="ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¡ä»¶ï¼ˆç§»å‹•å¾Œï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Scroll condition
        html += '<div style="background-color: #f3e5f5; border: 2px solid #9c27b0; border-radius: 8px; padding: 15px; margin-bottom: 15px;">';
        html += '<h3 style="color: #7b1fa2; margin: 0 0 15px 0; font-size: 18px;">â†”ï¸ ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¡ä»¶</h3>';
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 250px;">';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>è¡¨ç¤ºï¼š</strong> ä¸€éƒ¨åˆ†ã ã‘ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>æ“ä½œï¼š</strong> ãƒã‚¦ã‚¹ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦èƒŒæ™¯ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãªãŒã‚‰æ¢ã—ã¾ã™</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto; display: flex; gap: 10px;">';
        html += '<img src="screen_shots/5_ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«_ã¯ã˜ã‚.png" alt="ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¡ä»¶ï¼ˆåˆæœŸï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '<img src="screen_shots/6_ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«_ç§»å‹•å¾Œ.png" alt="ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¡ä»¶ï¼ˆç§»å‹•å¾Œï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        html += '</div>';

        // Memory recall with image
        html += '<div style="background-color: #fff3cd; border: 2px solid #ffeaa7; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h2 style="color: #856404; margin-top: 0; font-size: 20px;">è¨˜æ†¶èª²é¡Œã®å›ç­”</h2>';
        html += '<div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 300px;">';
        html += '<p style="font-size: 16px; margin: 10px 0;">å›³å½¢æ¢ç´¢ã®å¾Œã€æœ€åˆã«è¦šãˆãŸè‰²ä»˜ãã‚»ãƒ«ã®ä½ç½®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å›ç­”ã—ã¦ãã ã•ã„ã€‚</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/8_è¨˜æ†¶èª²é¡Œ_å›ç­”.png" alt="è¨˜æ†¶èª²é¡Œã®å›ç­”ä¾‹" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Continue button
        html += '<div style="text-align: center; margin-top: 40px;">';
        html += '<button id="initial-continue-btn" style="background-color: #007bff; color: white; border: none; padding: 15px 30px; font-size: 18px; border-radius: 8px; cursor: pointer; font-weight: bold;">ç·´ç¿’ã«é€²ã‚€</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const continueBtn = document.getElementById('initial-continue-btn');
        continueBtn.addEventListener('click', function() {
          // Add fullscreen request before starting practice
          enterFullscreen();
          // Small delay to allow fullscreen transition
          setTimeout(() => {
            jsPsych.finishTrial();
          }, 500);
        });
      }
    };

    // Initial explanation for memory-second group (å¾ŒåŠãŒè¨˜æ†¶èª²é¡Œã‚°ãƒ«ãƒ¼ãƒ—)
    const initialExplanationMemorySecond = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 900px; margin: 0 auto; padding: 40px; font-family: \'Noto Sans JP\', \'ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro\', \'Hiragino Kaku Gothic Pro\', \'ãƒ¡ã‚¤ãƒªã‚ª\', Meiryo, sans-serif; line-height: 1.8; background-color: #ffffff;">';
        
        // Title
        html += '<h1 style="text-align: center; color: #2c3e50; margin-bottom: 40px; font-size: 28px; font-weight: bold;">ãƒ«ãƒ¼ãƒ«èª¬æ˜</h1>';
        
        // Target presentation with image
        html += '<div style="background-color: #d1ecf1; border: 2px solid #bee5eb; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h2 style="color: #0c5460; margin-top: 0; font-size: 20px;">ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢ã®ç¢ºèª</h2>';
        html += '<div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 300px;">';
        html += '<p style="font-size: 16px; margin: 10px 0;">ã¾ãšã€æ¢ã™å›³å½¢ãŒ1ç§’é–“è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚è‰²ã¨å½¢ã‚’ã—ã£ã‹ã‚Šè¦šãˆã¦ãã ã•ã„ã€‚</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/1_ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå‘ˆç¤º.png" alt="ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢ã®è¡¨ç¤ºä¾‹" style="max-width: 200px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';

        // 3 viewing conditions
        html += '<div style="margin-bottom: 25px;">';
        html += '<h2 style="color: #dc3545; font-size: 20px; margin-bottom: 15px;">3ã¤ã®è¡¨ç¤ºæ¡ä»¶</h2>';
        
        // Fullscreen condition
        html += '<div style="background-color: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 15px; margin-bottom: 15px;">';
        html += '<h3 style="color: #1976d2; margin: 0 0 15px 0; font-size: 18px;">ğŸ–¥ï¸ å…¨ç”»é¢æ¡ä»¶</h3>';
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 250px;">';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>è¡¨ç¤ºï¼š</strong> ç”»é¢å…¨ä½“ã«å›³å½¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>æ“ä½œï¼š</strong> è‡ªç”±ã«ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã—ã¦å›³å½¢ã‚’æ¢ã—ã¾ã™</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/2_å…¨ç”»é¢.png" alt="å…¨ç”»é¢æ¡ä»¶ã®ä¾‹" style="max-width: 180px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Window condition
        html += '<div style="background-color: #fff3e0; border: 2px solid #ff9800; border-radius: 8px; padding: 15px; margin-bottom: 15px;">';
        html += '<h3 style="color: #f57c00; margin: 0 0 15px 0; font-size: 18px;">ğŸªŸ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¡ä»¶</h3>';
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 250px;">';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>è¡¨ç¤ºï¼š</strong> å°ã•ãªçª“ã‹ã‚‰å›³å½¢ã‚’è¦³å¯Ÿã—ã¾ã™</p>';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>æ“ä½œï¼š</strong> ãƒã‚¦ã‚¹ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦çª“ã‚’ç§»å‹•ã•ã›ãªãŒã‚‰æ¢ã—ã¾ã™</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto; display: flex; gap: 10px;">';
        html += '<img src="screen_shots/3_ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦_ã¯ã˜ã‚.png" alt="ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¡ä»¶ï¼ˆåˆæœŸï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '<img src="screen_shots/4_ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦_ç§»å‹•å¾Œ.png" alt="ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¡ä»¶ï¼ˆç§»å‹•å¾Œï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Scroll condition
        html += '<div style="background-color: #f3e5f5; border: 2px solid #9c27b0; border-radius: 8px; padding: 15px; margin-bottom: 15px;">';
        html += '<h3 style="color: #7b1fa2; margin: 0 0 15px 0; font-size: 18px;">â†”ï¸ ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¡ä»¶</h3>';
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 250px;">';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>è¡¨ç¤ºï¼š</strong> ä¸€éƒ¨åˆ†ã ã‘ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>';
        html += '<p style="margin: 5px 0; font-size: 15px;"><strong>æ“ä½œï¼š</strong> ãƒã‚¦ã‚¹ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦èƒŒæ™¯ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ãªãŒã‚‰æ¢ã—ã¾ã™</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto; display: flex; gap: 10px;">';
        html += '<img src="screen_shots/5_ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«_ã¯ã˜ã‚.png" alt="ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¡ä»¶ï¼ˆåˆæœŸï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '<img src="screen_shots/6_ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«_ç§»å‹•å¾Œ.png" alt="ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¡ä»¶ï¼ˆç§»å‹•å¾Œï¼‰" style="max-width: 90px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        html += '</div>';

        // Simple task flow
        html += '<div style="background-color: #f8f9fa; border: 2px solid #6c757d; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h2 style="color: #495057; margin-top: 0; font-size: 20px;">å‰åŠã®æµã‚Œ</h2>';
        html += '<p style="font-size: 16px; margin: 10px 0;">å‰åŠã¯å›³å½¢æ¢ç´¢ã®ã¿ã§ã™ã€‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢ã‚’è¦‹ã¤ã‘ã¦æ­£ç¢ºã«ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</p>';
        html += '<p style="font-size: 16px; margin: 10px 0; color: #6c757d;">â€»å¾ŒåŠã‹ã‚‰è¨˜æ†¶èª²é¡ŒãŒè¿½åŠ ã•ã‚Œã¾ã™</p>';
        html += '</div>';
        
        // Continue button
        html += '<div style="text-align: center; margin-top: 40px;">';
        html += '<button id="initial-continue-btn" style="background-color: #007bff; color: white; border: none; padding: 15px 30px; font-size: 18px; border-radius: 8px; cursor: pointer; font-weight: bold;">ç·´ç¿’ã«é€²ã‚€</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const continueBtn = document.getElementById('initial-continue-btn');
        continueBtn.addEventListener('click', function() {
          // Add fullscreen request before starting practice
          enterFullscreen();
          // Small delay to allow fullscreen transition
          setTimeout(() => {
            jsPsych.finishTrial();
          }, 500);
        });
      }
    };

    // Midpoint explanation for memory-first group (å‰åŠãŒè¨˜æ†¶èª²é¡Œã‚°ãƒ«ãƒ¼ãƒ—)
    const midpointExplanationMemoryFirst = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 900px; margin: 0 auto; padding: 40px; font-family: \'Noto Sans JP\', \'ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro\', \'Hiragino Kaku Gothic Pro\', \'ãƒ¡ã‚¤ãƒªã‚ª\', Meiryo, sans-serif; line-height: 1.8; background-color: #ffffff; text-align: center;">';
        
        html += '<h1 style="color: #2c3e50; margin-bottom: 30px; font-size: 28px; font-weight: bold;">ã“ã‚Œã§å‰åŠãŒçµ‚äº†ã§ã™</h1>';
        
        // Progress indicator
        html += '<div style="background-color: #d4edda; border: 2px solid #c3e6cb; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h2 style="color: #155724; margin-top: 0; font-size: 20px;">âœ… å‰åŠï¼šè¨˜æ†¶èª²é¡Œ + å›³å½¢æ¢ç´¢ å®Œäº†</h2>';
        html += '<p style="font-size: 16px; margin: 10px 0; color: #155724;">ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼å‰åŠã®è¨˜æ†¶èª²é¡Œä»˜ãã®è©¦è¡ŒãŒçµ‚äº†ã—ã¾ã—ãŸã€‚</p>';
        html += '</div>';
        
        // What changes in second half
        html += '<div style="background-color: #cff4fc; border: 2px solid #b6effb; border-radius: 8px; padding: 20px; margin-bottom: 25px; text-align: left;">';
        html += '<h2 style="color: #055160; margin-top: 0; font-size: 20px;">å¾ŒåŠã®å¤‰æ›´ç‚¹</h2>';
        html += '<p style="font-size: 16px; margin: 10px 0; color: #055160;">å¾ŒåŠã¯è¨˜æ†¶èª²é¡ŒãŒãªããªã‚Šã€å›³å½¢æ¢ç´¢ã®ã¿ã«ãªã‚Šã¾ã™ã€‚</p>';
        
        // Show target presentation image
        html += '<div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap; margin-top: 15px;">';
        html += '<div style="flex: 1; min-width: 300px;">';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #055160;"><strong>æ‰‹é †ï¼š</strong></p>';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #055160;">1. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢ã®ç¢ºèªï¼ˆ1ç§’é–“ï¼‰</p>';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #055160;">2. å›³å½¢æ¢ç´¢ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§å›ç­”ï¼‰</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/1_ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå‘ˆç¤º.png" alt="ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢ã®è¡¨ç¤ºä¾‹" style="max-width: 150px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Encouragement
        html += '<p style="font-size: 18px; margin: 20px 0; color: #333;">è¨˜æ†¶èª²é¡ŒãŒãªããªã‚‹ã®ã§ã€å›³å½¢æ¢ç´¢ã«é›†ä¸­ã§ãã¾ã™ï¼</p>';
        html += '<p style="font-size: 18px; margin: 20px 0; color: #333;">æœ€å¾Œã¾ã§é›†ä¸­ã—ã¦é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼</p>';
        
        // Continue button
        html += '<div style="margin-top: 40px;">';
        html += '<button id="midpoint-continue-btn" style="background-color: #007bff; color: white; border: none; padding: 15px 30px; font-size: 18px; border-radius: 8px; cursor: pointer; font-weight: bold;">å¾ŒåŠé–‹å§‹</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const continueBtn = document.getElementById('midpoint-continue-btn');
        continueBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Midpoint explanation for memory-second group (å¾ŒåŠãŒè¨˜æ†¶èª²é¡Œã‚°ãƒ«ãƒ¼ãƒ—)
    const midpointExplanationMemorySecond = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 900px; margin: 0 auto; padding: 40px; font-family: \'Noto Sans JP\', \'ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro\', \'Hiragino Kaku Gothic Pro\', \'ãƒ¡ã‚¤ãƒªã‚ª\', Meiryo, sans-serif; line-height: 1.8; background-color: #ffffff; text-align: center;">';
        
        html += '<h1 style="color: #2c3e50; margin-bottom: 30px; font-size: 28px; font-weight: bold;">ã“ã‚Œã§å‰åŠãŒçµ‚äº†ã§ã™</h1>';
        
        // Progress indicator
        html += '<div style="background-color: #d4edda; border: 2px solid #c3e6cb; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h2 style="color: #155724; margin-top: 0; font-size: 20px;">âœ… å‰åŠï¼šå›³å½¢æ¢ç´¢ã®ã¿ å®Œäº†</h2>';
        html += '<p style="font-size: 16px; margin: 10px 0; color: #155724;">ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼å‰åŠã®å›³å½¢æ¢ç´¢ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚</p>';
        html += '</div>';
        
        // What changes in second half - Memory task explanation with images
        html += '<div style="background-color: #fff3cd; border: 2px solid #ffeaa7; border-radius: 8px; padding: 20px; margin-bottom: 25px; text-align: left;">';
        html += '<h2 style="color: #856404; margin-top: 0; font-size: 20px;">å¾ŒåŠã®å¤‰æ›´ç‚¹ï¼šè¨˜æ†¶èª²é¡Œã‚’è¿½åŠ </h2>';
        html += '<p style="font-size: 16px; margin: 10px 0; color: #856404;">å¾ŒåŠã¯ãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ¡ãƒ¢ãƒªã‚’ä½¿ã†è¨˜æ†¶èª²é¡ŒãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚</p>';
        
        // Memory task presentation
        html += '<div style="margin: 15px 0; padding: 15px; background-color: #fffbf0; border-radius: 5px;">';
        html += '<h3 style="color: #856404; margin-top: 0; font-size: 16px;">è¨˜æ†¶èª²é¡Œã®æµã‚Œ</h3>';
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">';
        html += '<div style="flex: 1; min-width: 200px;">';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #856404;"><strong>1. è¨˜æ†¶èª²é¡Œï¼ˆ3ç§’é–“ï¼‰</strong></p>';
        html += '<p style="font-size: 14px; margin: 5px 0; color: #856404;">4Ã—4ã‚°ãƒªãƒƒãƒ‰ã®è‰²ä»˜ãã‚»ãƒ«ã®ä½ç½®ã‚’è¦šãˆã‚‹</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/7_è¨˜æ†¶èª²é¡Œ_å‘ˆç¤º.png" alt="è¨˜æ†¶èª²é¡Œã®è¡¨ç¤º" style="max-width: 120px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">';
        html += '<div style="flex: 1; min-width: 200px;">';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #856404;"><strong>2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç¢ºèª</strong></p>';
        html += '<p style="font-size: 14px; margin: 5px 0; color: #856404;">æ¢ã™å›³å½¢ã‚’1ç§’é–“ç¢ºèª</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/1_ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå‘ˆç¤º.png" alt="ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›³å½¢" style="max-width: 120px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        
        html += '<div style="color: #856404; font-size: 15px; margin: 10px 0;"><strong>3. å›³å½¢æ¢ç´¢</strong> â†’ ä»Šã¾ã§é€šã‚Šã®å›³å½¢æ¢ç´¢ã‚’å®Ÿè¡Œ</div>';
        
        html += '<div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="flex: 1; min-width: 200px;">';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #856404;"><strong>4. è¨˜æ†¶èª²é¡Œå›ç­”</strong></p>';
        html += '<p style="font-size: 14px; margin: 5px 0; color: #856404;">æœ€åˆã«è¦šãˆãŸè‰²ä»˜ãã‚»ãƒ«ã®ä½ç½®ã‚’ã‚¯ãƒªãƒƒã‚¯</p>';
        html += '</div>';
        html += '<div style="flex: 0 0 auto;">';
        html += '<img src="screen_shots/8_è¨˜æ†¶èª²é¡Œ_å›ç­”.png" alt="è¨˜æ†¶èª²é¡Œã®å›ç­”" style="max-width: 120px; height: auto; border: 2px solid #ddd; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        html += '</div>';
        
        // Tips
        html += '<div style="background-color: #e2e3e5; border: 2px solid #d3d3d4; border-radius: 8px; padding: 15px; margin-bottom: 25px; text-align: left;">';
        html += '<h3 style="color: #383d41; margin-top: 0; font-size: 18px;">ğŸ’¡ å¾ŒåŠã®ã‚³ãƒ„</h3>';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #383d41;">â€¢ å›³å½¢æ¢ç´¢ã«é›†ä¸­ã—ã™ããšã€è¨˜æ†¶èª²é¡Œã‚‚å¿˜ã‚Œãšã«</p>';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #383d41;">â€¢ è‰²ä»˜ãã‚»ãƒ«ã®ä½ç½®ã¯å›³å½¢æ¢ç´¢ä¸­ã‚‚é ­ã®ç‰‡éš…ã§è¦šãˆã¦ãŠã</p>';
        html += '<p style="font-size: 15px; margin: 5px 0; color: #383d41;">â€¢ ä¸¡æ–¹ã®èª²é¡Œã‚’ãƒãƒ©ãƒ³ã‚¹ã‚ˆãè¡Œã†ã“ã¨ãŒé‡è¦</p>';
        html += '</div>';
        
        html += '<p style="font-size: 18px; margin: 20px 0; color: #333;">å¾ŒåŠã‚‚ã•ã‚‰ã«é›†ä¸­ã—ã¦é ‘å¼µã£ã¦ãã ã•ã„ï¼</p>';
        
        // Continue button
        html += '<div style="margin-top: 40px;">';
        html += '<button id="midpoint-continue-btn" style="background-color: #007bff; color: white; border: none; padding: 15px 30px; font-size: 18px; border-radius: 8px; cursor: pointer; font-weight: bold;">å¾ŒåŠé–‹å§‹</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const continueBtn = document.getElementById('midpoint-continue-btn');
        continueBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Instructions for visual search task
    const visualSearchInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        const viewCondition = jsPsych.timelineVariable('viewCondition');
        const isPractice = jsPsych.timelineVariable('isPractice') || false;
        
        // Generate progress display for main trials only
        let progressDisplay = '';
        if (!isPractice) {
          // Increment trial counter for main trials
          currentMainTrialNumber++;
          progressDisplay = `<p style="font-size: 16px; margin: 10px 0; font-weight: bold; color: #007bff;">${currentMainTrialNumber}å›/${totalMainTrials}å›</p>`;
        }
        
        return `
          ${progressDisplay}
          <p>æ¬¡ã¯<strong>${viewCondition === 'window' ? 'ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¡ä»¶' : 
            viewCondition === 'scroll' ? 'ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¡ä»¶' : 'å…¨ç”»é¢æ¡ä»¶'}</strong></p>
          <p>${viewCondition === 'window' ? 
            'ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’å‹•ã‹ã—ã¦æ¢ç´¢ã—ã¾ã™ã€‚' : 
            viewCondition === 'scroll' ? 
            'èƒŒæ™¯ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦æ¢ç´¢ã—ã¾ã™ã€‚' : 
            'å…¨ç”»é¢ã§æ¢ç´¢ã‚’ã—ã¾ã™'}</p>
          <p><strong>ä¸‹ã®ã€Œæ¬¡ã¸ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹å§‹ã—ã¾ã™ã€‚</strong></p>
          <div style="margin: 20px 0;">
            <button id="visual-search-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">æ¬¡ã¸</button>
          </div>
        `;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('visual-search-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Memory grid task - display
    const memoryGridDisplay = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Generate the memory positions to remember
        memoryPositions = [];
        const gridSize = params.memoryGridSize;
        
        // Randomly select positions
        while (memoryPositions.length < params.memoryPositions) {
          const row = Math.floor(Math.random() * gridSize);
          const col = Math.floor(Math.random() * gridSize);
          const position = row * gridSize + col;
          
          // Ensure no duplicates
          if (!memoryPositions.includes(position)) {
            memoryPositions.push(position);
          }
        }
        
        // Create the grid HTML
        let gridHTML = '<h1>è¨˜æ†¶èª²é¡Œ</h1>';
        gridHTML += '<p>ä»¥ä¸‹ã®ã‚°ãƒªãƒƒãƒ‰å†…ã®è‰²ã®ã¤ã„ãŸã‚»ãƒ«ã®ä½ç½®ã‚’è¨˜æ†¶ã—ã¦ãã ã•ã„ã€‚</p>';
        gridHTML += '<div id="memory-grid">';
        
        for (let i = 0; i < gridSize * gridSize; i++) {
          const isHighlighted = memoryPositions.includes(i);
          gridHTML += `<div class="memory-cell ${isHighlighted ? 'highlighted' : ''}" data-index="${i}"></div>`;
        }
        
        gridHTML += '</div>';
        gridHTML += '<p>3ç§’é–“è¡¨ç¤ºã•ã‚ŒãŸå¾Œã€è‡ªå‹•çš„ã«æ¬¡ã¸é€²ã¿ã¾ã™ã€‚</p>';
        
        return gridHTML;
      },
      choices: "NO_KEYS",
      trial_duration: 3000, // Display for 3 seconds
      data: {
        task: 'memory_display',
        memory_positions: function() { return memoryPositions; }
      }
    };

    // Memory grid task - recall (reproduction format)
    const memoryGridRecall = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        const gridSize = params.memoryGridSize;
        
        // Create the HTML with a blank interactive grid
        let gridHTML = '<h1>è¨˜æ†¶èª²é¡Œ - å›ç­”</h1>';
        gridHTML += '<p>è¨˜æ†¶ã—ãŸä½ç½®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å†ç¾ã—ã¦ãã ã•ã„ã€‚</p>';
        gridHTML += '<div id="memory-reproduction-grid" class="memory-reproduction-grid">';
        
        for (let i = 0; i < gridSize * gridSize; i++) {
          gridHTML += `<div class="reproduction-cell" data-index="${i}"></div>`;
        }
        
        gridHTML += '</div>';
        gridHTML += '<button id="memory-reset-btn" class="memory-reset-btn">ãƒªã‚»ãƒƒãƒˆ</button>';
        gridHTML += '<button id="memory-submit-btn" class="memory-submit-btn" disabled>æ±ºå®š</button>';
        gridHTML += '<p id="selection-info">3ã¤ã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>';
        
        return gridHTML;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Initialize selected positions array
        selectedMemoryPositions = [];
        
        const cells = document.querySelectorAll('.reproduction-cell');
        const submitBtn = document.getElementById('memory-submit-btn');
        const selectionInfo = document.getElementById('selection-info');
        
        // Add click event listeners to all cells
        cells.forEach(cell => {
          cell.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-index'));
            const isSelected = this.classList.contains('selected');
            
            // Only allow selection if cell is not already selected and limit not reached
            if (!isSelected && selectedMemoryPositions.length < params.memoryPositions) {
              this.classList.add('selected');
              selectedMemoryPositions.push(index);
            }
            
            // Update UI based on selection count
            const selectedCount = selectedMemoryPositions.length;
            if (selectedCount === params.memoryPositions) {
              submitBtn.disabled = false;
              selectionInfo.textContent = `${selectedCount}ã¤ã®ã‚»ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚æ±ºå®šãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`;
            } else {
              submitBtn.disabled = true;
              selectionInfo.textContent = `${selectedCount}ã¤ã®ã‚»ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚ã‚ã¨${params.memoryPositions - selectedCount}ã¤é¸æŠã—ã¦ãã ã•ã„ã€‚`;
            }
          });
        });
        
        // Add submit button event listener
        submitBtn.addEventListener('click', function() {
          if (selectedMemoryPositions.length === params.memoryPositions) {
            // Calculate accuracy
            const correctCount = selectedMemoryPositions.filter(pos => memoryPositions.includes(pos)).length;
            const accuracy = correctCount / params.memoryPositions;
            const isCorrect = accuracy === 1.0; // Perfect match required
            
            jsPsych.finishTrial({
              memory_selected_positions: selectedMemoryPositions,
              memory_correct_positions: memoryPositions,
              memory_accuracy: accuracy,
              memory_correct: isCorrect ? 1 : 0
            });
          }
        });
        
        // Add reset button event listener
        const resetBtn = document.getElementById('memory-reset-btn');
        resetBtn.addEventListener('click', function() {
          // Clear all selections
          selectedMemoryPositions = [];
          cells.forEach(cell => {
            cell.classList.remove('selected');
          });
          
          // Update UI
          submitBtn.disabled = true;
          selectionInfo.textContent = `0ã¤ã®ã‚»ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚ã‚ã¨${params.memoryPositions}ã¤é¸æŠã—ã¦ãã ã•ã„ã€‚`;
        });
      }
    };

    // Calculate memory task accuracy
    function calculateMemoryAccuracy(correct, selected) {
      let correctCount = 0;
      for (let pos of selected) {
        if (correct.includes(pos)) {
          correctCount++;
        }
      }
      return correctCount / params.memoryPositions;
    }

    // Fixation point display
    const fixationPoint = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="display: flex; align-items: center; justify-content: center; height: 100vh;">
          <div style="font-size: 60px; font-weight: bold; color: black;">+</div>
        </div>
      `,
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: {
        task: 'fixation_point'
      }
    };

    // Blank screen display (500ms white screen)
    const blankScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background-color: white;">
        </div>
      `,
      choices: "NO_KEYS",
      trial_duration: 500,
      data: {
        task: 'blank_screen'
      }
    };

    // Display target object
    const showTarget = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Randomly select target color and shape
        const targetColor = jsPsych.randomization.sampleWithoutReplacement(params.colors, 1)[0];
        const targetShape = jsPsych.randomization.sampleWithoutReplacement(params.shapes, 1)[0];
        
        // Store in data for the visual search task
        jsPsych.data.addProperties({
          target_color: targetColor,
          target_shape: targetShape
        });
        
        return `
          <div style="margin: 20px auto; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;">
            <canvas id="target-canvas" width="60" height="60"></canvas>
          </div>
        `;
      },
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: {
        task: 'show_target'
      },
      on_load: function() {
        // Get target information from data
        const data = jsPsych.data.get().last(1).values()[0];
        const targetColor = data.target_color;
        const targetShape = data.target_shape;
        
        // Draw target on canvas using the same method as search objects
        const canvas = document.getElementById('target-canvas');
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw target object at center of canvas using same drawObject function
        drawObject(ctx, 30, 30, getTargetPresentationSize(), targetColor, targetShape);
      }
    };

    // Draw a shape on canvas or SVG
    function drawShape(shape, color, x, y, size) {
      const halfSize = size / 2;
      
      switch (shape) {
        case 'circle':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <circle cx="${halfSize}" cy="${halfSize}" r="${halfSize * 0.8}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'triangle':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <polygon points="${halfSize},${size * 0.2} ${size * 0.2},${size * 0.8} ${size * 0.8},${size * 0.8}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'square':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <rect x="${size * 0.2}" y="${size * 0.2}" width="${size * 0.6}" height="${size * 0.6}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'diamond':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <polygon points="${halfSize},${size * 0.2} ${size * 0.8},${halfSize} ${halfSize},${size * 0.8} ${size * 0.2},${halfSize}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        default:
          return `<svg width="${size}" height="${size}"><circle cx="${halfSize}" cy="${halfSize}" r="${halfSize}" fill="${color}" stroke="black" stroke-width="2" /></svg>`;
      }
    }

    // Visual search task
    const visualSearch = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        return `<div id="search-container" style="width: 100vw; height: 100vh;"></div>`;
      },
      choices: "NO_KEYS",
      data: {
        task: 'visual_search'
      },
      on_load: function() {
        // Get trial parameters
        const viewCondition = jsPsych.timelineVariable('viewCondition');
        const structure = jsPsych.timelineVariable('structure');
        
        // Get target information
        const targetColor = jsPsych.data.get().last(1).values()[0].target_color;
        const targetShape = jsPsych.data.get().last(1).values()[0].target_shape;
        
        // Setup canvas
        const canvas = document.getElementById('jspsych-visual-search-canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.classList.remove('hidden');
        canvas.style.display = 'block';
        canvas.style.cursor = 'pointer'; // Only set cursor during visual search
        canvas.style.zIndex = '20'; // Set higher z-index during visual search
        canvas.style.pointerEvents = 'auto'; // Enable pointer events during visual search
        
        const ctx = canvas.getContext('2d');
        
        // Setup search window for window and scroll conditions
        const searchWindow = document.getElementById('search-window');
        if (viewCondition !== 'fullscreen') {
          searchWindow.style.width = params.windowWidth + 'px';
          searchWindow.style.height = params.windowHeight + 'px';
          searchWindow.classList.remove('hidden');
          searchWindow.style.display = 'block'; // Ensure search window is visible (reset from previous trial)
          // ä¸­å¤®ã«å›ºå®š
          searchWindow.style.left = '50%';
          searchWindow.style.top = '50%';
          searchWindow.style.transform = 'translate(-50%, -50%)';
          
          // Enable pointer events for window condition to allow dragging
          if (viewCondition === 'window') {
            searchWindow.style.pointerEvents = 'auto';
          } else {
            searchWindow.style.pointerEvents = 'none';
          }
        }
        
        // Create visual search display
        const searchArea = {
          width: params.screenWidth,
          height: params.screenHeight
        };
        
        // Reset movement tracking
        mousePath = [];
        totalMovement = 0;
        currentDragDistance = 0; // Reset current drag distance for new trial
        justFinishedDrag = false; // Reset drag finish flag for new trial
        lastMouseX = params.screenWidth / 2;
        lastMouseY = params.screenHeight / 2;
        
        // Generate objects
        const isPractice = jsPsych.timelineVariable('isPractice') || false;
        generateObjects(searchArea, targetColor, targetShape, structure, viewCondition, isPractice);
        
        // Initial draw
        drawSearchDisplay(ctx, viewCondition);
        
        // Start timer
        const startTime = performance.now();
        
        // Setup event listeners
        if (viewCondition === 'window') {
          // Window condition - drag to move the window
          searchWindow.addEventListener('mousedown', startWindowDrag);
          document.addEventListener('mousemove', dragWindow);
          document.addEventListener('mouseup', endWindowDrag);
          // Add click event listener to search window for object selection
          searchWindow.addEventListener('click', checkSelection);
        } else if (viewCondition === 'scroll') {
          // Scroll condition - drag the background
          canvas.addEventListener('mousedown', startDrag);
          document.addEventListener('mousemove', dragBackground);
          document.addEventListener('mouseup', endDrag);
        }
        
        // Click to select object (for fullscreen and scroll conditions)
        if (viewCondition !== 'window') {
          canvas.addEventListener('click', checkSelection);
        }
        
        // Event handler functions
        function startWindowDrag(e) {
          // Only start drag if clicking within the window
          isMouseDown = true;
          mouseX = e.clientX;
          mouseY = e.clientY;
          lastMouseX = mouseX;
          lastMouseY = mouseY;
          currentDragDistance = 0; // Reset drag distance for new interaction
          
          // Calculate offset between cursor and window position
          const searchWindow = document.getElementById('search-window');
          const windowRect = searchWindow.getBoundingClientRect();
          
          // Remove CSS transform and set absolute positioning
          searchWindow.style.transform = 'none';
          searchWindow.style.left = windowRect.left + 'px';
          searchWindow.style.top = windowRect.top + 'px';
          
          // Now calculate the offset with the corrected position
          dragOffsetX = mouseX - windowRect.left;
          dragOffsetY = mouseY - windowRect.top;
        }
        
        function dragWindow(e) {
          if (!isMouseDown && viewCondition === 'window') return; // Only move during drag
          
          mouseX = e.clientX;
          mouseY = e.clientY;
          
          if (viewCondition === 'window' && isMouseDown) {
            // Calculate movement distance
            const dx = mouseX - lastMouseX;
            const dy = mouseY - lastMouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Update total movement and path
            totalMovement += distance;
            currentDragDistance += distance; // Track current interaction drag distance
            mousePath.push({x: mouseX, y: mouseY, time: performance.now() - startTime});
            
            // Update last position
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Move the window using the stored offset
            let windowX = mouseX - dragOffsetX;
            let windowY = mouseY - dragOffsetY;
            
            // Keep window within screen bounds
            windowX = Math.max(0, Math.min(windowX, params.screenWidth - params.windowWidth));
            windowY = Math.max(0, Math.min(windowY, params.screenHeight - params.windowHeight));
            
            searchWindow.style.left = windowX + 'px';
            searchWindow.style.top = windowY + 'px';
            
            // Update canvas clip region
            drawSearchDisplay(ctx, viewCondition);
          }
        }
        
        function endWindowDrag() {
          isMouseDown = false;
          // If there was significant drag, mark it to prevent immediate clicks
          if (currentDragDistance > 5) {
            justFinishedDrag = true;
            setTimeout(() => {
              justFinishedDrag = false;
            }, 50); // Small delay to prevent click events immediately after drag
          }
        }
        
        function startDrag(e) {
          isMouseDown = true;
          mouseX = e.clientX;
          mouseY = e.clientY;
          lastMouseX = mouseX;
          lastMouseY = mouseY;
          currentDragDistance = 0; // Reset drag distance for new interaction
        }
        
        function dragBackground(e) {
          if (!isMouseDown && viewCondition === 'scroll') return;
          
          mouseX = e.clientX;
          mouseY = e.clientY;
          
          if (viewCondition === 'scroll' && isMouseDown) {
            // Calculate movement distance
            const dx = mouseX - lastMouseX;
            const dy = mouseY - lastMouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Update total movement and path
            totalMovement += distance;
            currentDragDistance += distance; // Track current interaction drag distance
            mousePath.push({x: mouseX, y: mouseY, time: performance.now() - startTime});
            
            // Move all objects
            for (let i = 0; i < objects.length; i++) {
              objects[i].x += dx;
              objects[i].y += dy;
            }
            
            // Update last position
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Redraw
            drawSearchDisplay(ctx, viewCondition);
          }
        }
        
        function endDrag() {
          isMouseDown = false;
        }
        
        function checkSelection(e) {
          const clickX = e.clientX;
          const clickY = e.clientY;
          
          // For scroll/window conditions, check if significant dragging occurred
          // If user dragged more than 5 pixels, don't treat this as a selection click
          if ((viewCondition === 'scroll' || viewCondition === 'window') && (currentDragDistance > 5 || justFinishedDrag)) {
            return; // Ignore click after significant drag or immediately after drag
          }
          
          // Check if click is within visible area for window/scroll conditions
          if (viewCondition !== 'fullscreen') {
            const windowRect = searchWindow.getBoundingClientRect();
            if (clickX < windowRect.left || clickX > windowRect.right || 
                clickY < windowRect.top || clickY > windowRect.bottom) {
              return; // Click outside visible area
            }
          }
          
          // Find clicked object using standard collision detection
          let clickedObject = null;
          
          for (let i = 0; i < objects.length; i++) {
            const obj = objects[i];
            const dx = clickX - obj.x;
            const dy = clickY - obj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= obj.size / 2) {
              clickedObject = obj;
              break;
            }
          }
          
          // If no object was clicked using standard detection, check for expanded target detection
          if (!clickedObject && targetObject) {
            const targetDx = clickX - targetObject.x;
            const targetDy = clickY - targetObject.y;
            const targetDistance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            // Calculate expanded hit radius for target
            const expandedTargetRadius = (targetObject.size / 2) + (targetObject.size * params.targetTolerance);
            
            if (targetDistance <= expandedTargetRadius) {
              clickedObject = targetObject;
            }
          }
          
          // Check if target was found
          const correct = clickedObject === targetObject;
          const rt = performance.now() - startTime;
          
          // Remove event listeners
          if (viewCondition === 'window') {
            searchWindow.removeEventListener('mousedown', startWindowDrag);
            document.removeEventListener('mousemove', dragWindow);
            document.removeEventListener('mouseup', endWindowDrag);
            searchWindow.removeEventListener('click', checkSelection);
            // Reset pointer events for search window
            searchWindow.style.pointerEvents = 'none';
          } else if (viewCondition === 'scroll') {
            canvas.removeEventListener('mousedown', startDrag);
            document.removeEventListener('mousemove', dragBackground);
            document.removeEventListener('mouseup', endDrag);
          }
          
          if (viewCondition !== 'window') {
            canvas.removeEventListener('click', checkSelection);
          }
          
          // Reset drag state
          isMouseDown = false;
          justFinishedDrag = false;
          
          // Hide canvas and window immediately using direct style property
          canvas.style.display = 'none';
          canvas.style.cursor = 'default'; // Reset cursor
          canvas.style.zIndex = '5'; // Reset z-index
          canvas.style.pointerEvents = 'none'; // Disable pointer events
          searchWindow.style.display = 'none';
          
          // Finish trial
          const memoryLoadCondition = jsPsych.timelineVariable('memoryLoad');
          const isPracticeCondition = jsPsych.timelineVariable('isPractice') || false;
          const trialData = {
            reaction_time: rt,
            correct: correct,
            view_condition: viewCondition,
            structure: structure,
            memory_load: memoryLoadCondition,
            wm_load: memoryLoadCondition === 'with-memory', // Boolean indicator for WM load presence
            practice_trial: isPracticeCondition, // Boolean indicator for practice trial
            target_color: targetColor,
            target_shape: targetShape,
            total_movement: totalMovement,
            mouse_path: mousePath,
            task: 'visual_search',
            is_practice: jsPsych.timelineVariable('isPractice') || false
          };
          
          // Only save data if not in practice mode
          if (!jsPsych.timelineVariable('isPractice')) {
            jsPsych.finishTrial(trialData);
          } else {
            // For practice, still finish trial but don't save to main data
            jsPsych.finishTrial(trialData);
          }
        }
      }
    };

    // Generate objects for visual search
    function generateObjects(area, targetColor, targetShape, structure, viewCondition, isPractice) {
      objects = [];
      let positions = [];
      
      // Use fixed object size for positioning calculations (to avoid overlaps)
      const avgObjectSize = params.objectSize;
      
      let targetX, targetY;
      
      // Calculate initial window bounds for practice trials
      let initialWindowBounds = null;
      if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
        // Initial window is centered on screen
        const windowCenterX = params.screenWidth / 2;
        const windowCenterY = params.screenHeight / 2;
        initialWindowBounds = {
          left: windowCenterX - params.windowWidth / 2,
          right: windowCenterX + params.windowWidth / 2,
          top: windowCenterY - params.windowHeight / 2,
          bottom: windowCenterY + params.windowHeight / 2
        };
      }
      
      // Helper function to check if target overlaps with initial window
      function isTargetInInitialWindow(x, y) {
        if (!initialWindowBounds) return false;
        
        // Check if target center is within window bounds
        // Add some padding to account for object size
        const padding = avgObjectSize / 2;
        return (x + padding > initialWindowBounds.left && 
                x - padding < initialWindowBounds.right &&
                y + padding > initialWindowBounds.top && 
                y - padding < initialWindowBounds.bottom);
      }
      
      if (structure === 'structured') {
        // For structured condition, create a grid layout
        const gridSize = Math.floor(Math.sqrt(params.numObjects));
        const cellWidth = area.width / gridSize;
        const cellHeight = area.height / gridSize;
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            positions.push({
              x: i * cellWidth + cellWidth / 2,
              y: j * cellHeight + cellHeight / 2
            });
          }
        }
        
        // For practice trials, filter out positions that would be in the initial window
        let availablePositions = positions;
        if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
          availablePositions = positions.filter(pos => !isTargetInInitialWindow(pos.x, pos.y));
          
          // If no positions are available outside the window, use all positions as fallback
          if (availablePositions.length === 0) {
            availablePositions = positions;
          }
        }
        
        // Randomly place target at one of the available positions
        const targetPosition = Math.floor(Math.random() * availablePositions.length);
        targetX = availablePositions[targetPosition].x;
        targetY = availablePositions[targetPosition].y;
        
        // Remove the target position from the original positions array
        const originalTargetIndex = positions.findIndex(pos => pos.x === targetX && pos.y === targetY);
        if (originalTargetIndex >= 0) {
          positions.splice(originalTargetIndex, 1);
        }
      } else {
        // Unstructured condition - random positions
        let attempts = 0;
        const maxAttempts = 50; // Prevent infinite loops
        
        do {
          targetX = Math.random() * (area.width - avgObjectSize * 2) + avgObjectSize;
          targetY = Math.random() * (area.height - avgObjectSize * 2) + avgObjectSize;
          attempts++;
        } while (isPractice && (viewCondition === 'window' || viewCondition === 'scroll') && 
                 isTargetInInitialWindow(targetX, targetY) && attempts < maxAttempts);
        
        // Generate random positions for distractors
        for (let i = 0; i < params.numObjects - 1; i++) {
          let x, y, overlapping;
          
          do {
            x = Math.random() * (area.width - avgObjectSize * 2) + avgObjectSize;
            y = Math.random() * (area.height - avgObjectSize * 2) + avgObjectSize;
            
            // Check if too close to target
            const dx = x - targetX;
            const dy = y - targetY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            overlapping = distance < avgObjectSize;
            
            // Check if too close to other positions
            for (let j = 0; j < positions.length && !overlapping; j++) {
              const dx = x - positions[j].x;
              const dy = y - positions[j].y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance < avgObjectSize) {
                overlapping = true;
              }
            }
          } while (overlapping);
          
          positions.push({x: x, y: y});
        }
      }
      
      // Create the target object
      targetObject = {
        x: targetX,
        y: targetY,
        size: getObjectSize(),
        color: targetColor,
        shape: targetShape,
        isTarget: true
      };
      
      objects.push(targetObject);
      
      // Create distractor objects
      for (let i = 0; i < params.numObjects - 1; i++) {
        if (i >= positions.length) break;
        
        let distractorColor, distractorShape;
        
        // Ensure at least one feature is different from target
        if (Math.random() < 0.5) {
          // Different color, same shape
          distractorColor = jsPsych.randomization.sampleWithoutReplacement(
            params.colors.filter(c => c !== targetColor), 1)[0];
          distractorShape = targetShape;
        } else {
          // Same color, different shape
          distractorColor = targetColor;
          distractorShape = jsPsych.randomization.sampleWithoutReplacement(
            params.shapes.filter(s => s !== targetShape), 1)[0];
        }
        
        // Some distractors might differ in both features
        if (Math.random() < 0.3) {
          distractorColor = jsPsych.randomization.sampleWithoutReplacement(
            params.colors.filter(c => c !== targetColor), 1)[0];
          distractorShape = jsPsych.randomization.sampleWithoutReplacement(
            params.shapes.filter(s => s !== targetShape), 1)[0];
        }
        
        objects.push({
          x: positions[i].x,
          y: positions[i].y,
          size: getObjectSize(),
          color: distractorColor,
          shape: distractorShape,
          isTarget: false
        });
      }
    }

    // Draw search display based on view condition
    function drawSearchDisplay(ctx, viewCondition) {
      ctx.clearRect(0, 0, params.screenWidth, params.screenHeight);
      
      if (viewCondition !== 'fullscreen') {
        // Clip to window area
        const searchWindow = document.getElementById('search-window');
        const windowRect = searchWindow.getBoundingClientRect();
        
        ctx.save();
        ctx.beginPath();
        ctx.rect(windowRect.left, windowRect.top, windowRect.width, windowRect.height);
        ctx.clip();
      }
      
      // Draw all objects
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        drawObject(ctx, obj.x, obj.y, obj.size, obj.color, obj.shape);
      }
      
      if (viewCondition !== 'fullscreen') {
        ctx.restore();
      }
    }

    // Draw an object on the canvas
    function drawObject(ctx, x, y, size, color, shape) {
      ctx.fillStyle = color;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      
      switch (shape) {
        case 'circle':
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          break;
        case 'triangle':
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.lineTo(x - size / 2, y + size / 2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
        case 'square':
          ctx.beginPath();
          ctx.rect(x - size / 2, y - size / 2, size, size);
          ctx.fill();
          ctx.stroke();
          break;
        case 'diamond':
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x + size / 2, y);
          ctx.lineTo(x, y + size / 2);
          ctx.lineTo(x - size / 2, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
      }
    }

    // Feedback for visual search task
    const searchFeedback = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Get the last visual search task data specifically
        const searchData = jsPsych.data.get().filter({task: 'visual_search'}).last(1).values()[0];
        const correct = searchData.correct;
        const reactionTimeMs = searchData.reaction_time;
        const reactionTimeSec = (reactionTimeMs / 1000).toFixed(1);
        
        return `
          <h1>${correct ? 'æ­£è§£!' : 'ä¸æ­£è§£'}</h1>
          <p style="font-size: 18px; margin-top: 20px;">ä»Šå›ã®ã‚¿ã‚¤ãƒ ï¼š${reactionTimeSec}ç§’</p>
        `;
      },
      data: {
        task: 'search_feedback'
      },
      choices: "NO_KEYS",
      trial_duration: 1000
    };

    // Feedback for memory task
    const memoryFeedback = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Get the last memory task data specifically
        const memoryData = jsPsych.data.get().filter({task: 'memory_recall'}).last(1).values()[0];
        const correct = memoryData.memory_correct === 1;
        
        return `
          <h1>${correct ? 'æ­£è§£!' : 'ä¸æ­£è§£'}</h1>
          <p>ä¸‹ã®ã€Œæ¬¡ã¸ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ¬¡ã«é€²ã¿ã¾ã™ã€‚</p>
          <div style="margin: 20px 0;">
            <button id="memory-feedback-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">æ¬¡ã¸</button>
          </div>
        `;
      },
      data: {
        task: 'memory_feedback'
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('memory-feedback-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // End screen with overall score
    const endScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Calculate overall accuracy for visual search
        const searchData = jsPsych.data.get().filter({task: 'visual_search'});
        const correctSearches = searchData.filter({correct: true}).count();
        const searchAccuracy = Math.round((correctSearches / searchData.count()) * 100);
        
        // Calculate average response time for visual search
        const searchTimes = searchData.select('rt').values;
        const avgSearchTime = searchTimes.reduce((a, b) => a + b, 0) / searchTimes.length;
        const avgSearchTimeSeconds = Math.round((avgSearchTime / 1000) * 100) / 100; // Convert to seconds, round to 2 decimals
        
        // Calculate overall memory task accuracy if applicable
        let memoryAccuracyText = '';
        const memoryScores = jsPsych.data.get().select('memory_correct').values;
        
        if (memoryScores && memoryScores.length > 0) {
          // Filter out undefined values and calculate mean
          const filteredScores = memoryScores.filter(score => score !== undefined);
          if (filteredScores.length > 0) {
            const avgMemoryAccuracy = filteredScores.reduce((a, b) => a + b, 0) / filteredScores.length;
            const memoryAccuracy = Math.round(avgMemoryAccuracy * 100);
            memoryAccuracyText = `<p style="font-size: 18px; margin: 15px 0;">ãƒ‘ãƒãƒ«è¨˜æ†¶ã®æ­£ç­”ç‡ï¼š${memoryAccuracy}ï¼…</p>`;
          }
        }
        
        return `
          <div style="max-width: 700px; margin: 0 auto; padding: 40px 20px; text-align: center; line-height: 1.6;">
            <h1 style="color: #2c3e50; margin-bottom: 30px;">å®Ÿé¨“ã¯çµ‚äº†ã§ã™ã€‚ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼</h1>
            
            <div style="background-color: #f8f9fa; padding: 30px; border-radius: 10px; margin: 30px 0;">
              <h2 style="color: #495057; margin-bottom: 20px;">å®Ÿé¨“çµæœ</h2>
              <p style="font-size: 18px; margin: 15px 0;">å›³å½¢æ¢ã—ã®æ­£ç­”ç‡ï¼š${searchAccuracy}ï¼…</p>
              <p style="font-size: 18px; margin: 15px 0;">å›³å½¢æ¢ã—ã®ã‚¹ãƒ”ãƒ¼ãƒ‰ï¼šå¹³å‡${avgSearchTimeSeconds}ç§’</p>
              ${memoryAccuracyText}
            </div>
            
            <div style="background-color: #e7f3ff; padding: 25px; border-radius: 10px; margin: 30px 0; text-align: left;">
              <h3 style="color: #0056b3; margin-bottom: 15px; text-align: center;">å®Ÿé¨“ã®çµ‚äº†ãƒ—ãƒ­ã‚»ã‚¹</h3>
              <ol style="font-size: 16px; line-height: 1.8; padding-left: 20px;">
                <li>ä¸‹ã®ã€Œçµ‚äº†ã™ã‚‹ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨å®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ã®é€ä¿¡ãŒè¡Œã‚ã‚Œã¾ã™ã€‚</li>
                <li>ãƒ‡ãƒ¼ã‚¿ã®é€ä¿¡ä¸­ã¯ã€ç”»é¢ã«è‹±èªãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚é€ä¿¡ãŒçµ‚ã‚ã‚‹ã¨çœŸã£ç™½ãªç”»é¢ã«ãªã‚Šã¾ã™ã€‚</li>
                <li>çœŸã£ç™½ãªç”»é¢ã«ãªã£ãŸã‚‰å®Ÿé¨“çµ‚äº†ã§ã™ã€‚ç”»é¢ã‚’é–‰ã˜ã¦æ§‹ã„ã¾ã›ã‚“ã€‚</li>
                <li>ã”å”åŠ›ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼</li>
              </ol>
            </div>
            
            <div style="margin: 30px 0;">
              <button id="end-screen-next-btn" style="padding: 15px 30px; font-size: 18px; background-color: #dc3545; color: white; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">çµ‚äº†ã™ã‚‹</button>
            </div>
          </div>
        `;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the End button
        const nextBtn = document.getElementById('end-screen-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Practice completion choice screen
    const practiceCompletionChoice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 600px; margin: 0 auto; padding: 20px; text-align: center;">';
        html += '<h1>ç·´ç¿’å®Œäº†</h1>';
        html += '<p style="font-size: 18px; margin: 20px 0;">6å›ã®ç·´ç¿’ãŒå®Œäº†ã—ã¾ã—ãŸã€‚</p>';
        html += '<p style="font-size: 16px; margin: 20px 0;">ä»¥ä¸‹ã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„ï¼š</p>';
        html += '<div style="margin: 30px 0;">';
        html += '<button id="practice-again-btn" style="padding: 15px 30px; font-size: 16px; background-color: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px;">ã‚‚ã†ä¸€åº¦ç·´ç¿’ã™ã‚‹</button>';
        html += '<button id="proceed-main-btn" style="padding: 15px 30px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 0 10px;">æœ¬ç•ªã¸é€²ã‚€</button>';
        html += '</div>';
        html += '</div>';
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const practiceAgainBtn = document.getElementById('practice-again-btn');
        const proceedMainBtn = document.getElementById('proceed-main-btn');
        
        practiceAgainBtn.addEventListener('click', function() {
          jsPsych.finishTrial({
            choice: 'practice_again'
          });
        });
        
        proceedMainBtn.addEventListener('click', function() {
          jsPsych.finishTrial({
            choice: 'proceed_main'
          });
        });
      }
    };

    // Main experiment start notice
    const mainExperimentStart = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="max-width: 600px; margin: 0 auto; padding: 20px; text-align: center;">
          <h1>æœ¬ç•ªé–‹å§‹</h1>
          <p style="font-size: 18px; margin: 20px 0;">ã“ã“ã‹ã‚‰æœ¬ç•ªã§ã™</p>
          <p style="font-size: 16px; margin: 20px 0;">
            ç·´ç¿’ã§ä½“é¨“ã—ãŸå†…å®¹ã¨åŒã˜èª²é¡Œã‚’è¡Œã„ã¾ã™ã€‚<br>
            é›†ä¸­ã—ã¦å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚
          </p>
          <p style="font-size: 16px; margin: 20px 0;">
            <strong>ä¸‹ã®ã€Œæ¬¡ã¸ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æœ¬ç•ªã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</strong>
          </p>
          <div style="margin: 20px 0;">
            <button id="main-experiment-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">æ¬¡ã¸</button>
          </div>
        </div>
      `,
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('main-experiment-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };


    // Counterbalancing logic for memory load conditions (moved earlier to determine practice trial structure)
    // Uses cognition.run CONDITION variable or falls back to random assignment for local testing
    let memoryFirstCondition = false; // Default: without-memory first, with-memory second
    
    if (typeof CONDITION !== 'undefined') {
      // cognition.run environment - use CONDITION variable for counterbalancing
      // CONDITION should be 0 or 1 (or other even/odd assignment)
      memoryFirstCondition = (CONDITION % 2 === 1);
      console.log('cognition.run CONDITION detected:', CONDITION, 'Memory first:', memoryFirstCondition);
    } else {
      // Local testing environment - use random assignment
      memoryFirstCondition = Math.random() < 0.5;
      console.log('Local testing - random assignment. Memory first:', memoryFirstCondition);
    }

    // Generate practice trial variables based on memory condition
    // Reduced from 9 to 6 trials (2 sets instead of 3)
    // Memory load depends on whether memory tasks are in the first block
    const practiceMemoryLoad = memoryFirstCondition ? 'with-memory' : 'without-memory';
    
    const practiceTrialVariables = [
      // First set
      { viewCondition: 'fullscreen', structure: 'structured', memoryLoad: practiceMemoryLoad, isPractice: true },
      { viewCondition: 'window', structure: 'structured', memoryLoad: practiceMemoryLoad, isPractice: true },
      { viewCondition: 'scroll', structure: 'structured', memoryLoad: practiceMemoryLoad, isPractice: true },
      // Second set
      { viewCondition: 'fullscreen', structure: 'structured', memoryLoad: practiceMemoryLoad, isPractice: true },
      { viewCondition: 'window', structure: 'structured', memoryLoad: practiceMemoryLoad, isPractice: true },
      { viewCondition: 'scroll', structure: 'structured', memoryLoad: practiceMemoryLoad, isPractice: true }
    ];

    // Create separate factorial designs for with-memory and without-memory conditions
    const viewAndStructureFactors = {
      viewCondition: ['window', 'scroll', 'fullscreen'],
      structure: ['structured', 'unstructured']
    };
    
    // Generate trial designs for both memory conditions
    const withoutMemoryDesign = jsPsych.randomization.factorial(viewAndStructureFactors, params.trialsPerCondition);
    withoutMemoryDesign.forEach(trial => {
      trial.memoryLoad = 'without-memory';
    });
    
    const withMemoryDesign = jsPsych.randomization.factorial(viewAndStructureFactors, params.trialsPerCondition);
    withMemoryDesign.forEach(trial => {
      trial.memoryLoad = 'with-memory';
    });

    // Assign first and second block procedures based on counterbalancing (memoryFirstCondition determined earlier)
    let firstBlockProcedureData, secondBlockProcedureData;
    if (memoryFirstCondition) {
      // Memory task first, then without memory
      firstBlockProcedureData = withMemoryDesign;
      secondBlockProcedureData = withoutMemoryDesign;
    } else {
      // Without memory first, then memory task (original order)
      firstBlockProcedureData = withoutMemoryDesign;
      secondBlockProcedureData = withMemoryDesign;
    }

    // Record counterbalancing assignment in experimental data
    jsPsych.data.addProperties({
      counterbalancing_condition: typeof CONDITION !== 'undefined' ? CONDITION : 'local_random',
      memory_first_block: memoryFirstCondition,
      block1_memory_load: memoryFirstCondition ? 'with-memory' : 'without-memory',
      block2_memory_load: memoryFirstCondition ? 'without-memory' : 'with-memory',
      assignment_source: typeof CONDITION !== 'undefined' ? 'cognition_run' : 'local_testing'
    });
    
    // Build timeline procedure for a single trial
    const trialProcedure = {
      timeline: [
        visualSearchInstructions,
        // Memory task is only included for 'with-memory' condition
        {
          timeline: [memoryGridDisplay],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        blankScreen,
        showTarget,
        blankScreen,
        visualSearch,
        // Search feedback for 'with-memory' condition comes immediately after visual search
        {
          timeline: [searchFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        // Memory recall only for 'with-memory' condition
        {
          timeline: [memoryGridRecall],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          },
          data: {
            task: 'memory_recall'
          }
        },
        // Memory feedback only for 'with-memory' condition
        {
          timeline: [memoryFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        // Search feedback for 'without-memory' condition comes at the end
        {
          timeline: [searchFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'without-memory';
          }
        }
      ]
    };
    
    // Practice trial procedure - includes memory tasks for memory-first groups
    const practiceTrialProcedure = memoryFirstCondition ? {
      // For memory-first groups: use full trial procedure with memory tasks
      timeline: [
        visualSearchInstructions,
        // Memory task is only included for 'with-memory' condition
        {
          timeline: [memoryGridDisplay],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        blankScreen,
        showTarget,
        blankScreen,
        visualSearch,
        // Search feedback for 'with-memory' condition comes immediately after visual search
        {
          timeline: [searchFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        // Memory recall only for 'with-memory' condition
        {
          timeline: [memoryGridRecall],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          },
          data: {
            task: 'memory_recall'
          }
        },
        // Memory feedback only for 'with-memory' condition
        {
          timeline: [memoryFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        // Search feedback for 'without-memory' condition comes at the end
        {
          timeline: [searchFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'without-memory';
          }
        }
      ]
    } : {
      // For memory-second groups: simplified version without memory tasks
      timeline: [
        visualSearchInstructions,
        blankScreen,
        showTarget,
        blankScreen,
        visualSearch,
        // Always show search feedback for practice (no memory component)
        searchFeedback
      ]
    };

    // Practice block procedure
    const practiceBlockProcedure = {
      ...practiceTrialProcedure,
      timeline_variables: practiceTrialVariables,
      randomize_order: false // Keep fixed order for practice
    };

    // Complete practice procedure with loop
    const practiceProcedure = {
      timeline: [
        practiceBlockProcedure,
        practiceCompletionChoice,
        {
          timeline: [practiceBlockProcedure],
          conditional_function: function() {
            // Check if user chose to practice again
            const lastChoice = jsPsych.data.get().last(1).values()[0];
            return lastChoice.choice === 'practice_again';
          }
        }
      ],
      loop_function: function() {
        // Check if user chose to practice again
        const lastChoice = jsPsych.data.get().last(1).values()[0];
        return lastChoice.choice === 'practice_again';
      }
    };

    // First block procedure (counterbalanced)
    const firstBlockProcedure = {
      ...trialProcedure,
      timeline_variables: firstBlockProcedureData,
      randomize_order: true
    };
    
    // Second block procedure (counterbalanced)
    const secondBlockProcedure = {
      ...trialProcedure,
      timeline_variables: secondBlockProcedureData,
      randomize_order: true
    };

    // Conditional initial explanation based on counterbalancing
    const conditionalInitialExplanation = {
      timeline: [initialExplanationMemoryFirst],
      conditional_function: function() {
        return memoryFirstCondition;
      }
    };
    
    const conditionalInitialExplanationSecond = {
      timeline: [initialExplanationMemorySecond],
      conditional_function: function() {
        return !memoryFirstCondition;
      }
    };

    // Conditional midpoint explanation based on counterbalancing
    const conditionalMidpointExplanation = {
      timeline: [midpointExplanationMemoryFirst],
      conditional_function: function() {
        return memoryFirstCondition;
      }
    };
    
    const conditionalMidpointExplanationSecond = {
      timeline: [midpointExplanationMemorySecond],
      conditional_function: function() {
        return !memoryFirstCondition;
      }
    };

    // Full experiment timeline
    const timeline = [
      welcome,
      informedConsent,
      demographics,
      conditionalInitialExplanation,
      conditionalInitialExplanationSecond,
      practiceProcedure,
      mainExperimentStart,
      firstBlockProcedure,
      conditionalMidpointExplanation,
      conditionalMidpointExplanationSecond,
      secondBlockProcedure,
      endScreen
    ];

    // Run the experiment using jsPsych v7 API (upgraded from v6.3.1)
    jsPsych.run(timeline);
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>NaN Edge Case Test</title>
  <meta charset="utf-8">
  <style>
    body { 
      font-family: Arial, sans-serif; 
      padding: 20px; 
      background-color: #f5f5f5; 
    }
    .test-result { 
      background: white; 
      padding: 20px; 
      margin: 10px 0; 
      border-radius: 5px; 
      border-left: 4px solid #007bff; 
    }
    .pass { border-left-color: #28a745; }
    .fail { border-left-color: #dc3545; }
  </style>
</head>
<body>
  <h1>NaN ã‚¨ãƒ©ãƒ¼ä¿®æ­£ãƒ†ã‚¹ãƒˆ</h1>
  <p>æ¤œç´¢ãƒ‡ãƒ¼ã‚¿ãŒç©ºã®å ´åˆã®NaNå•é¡ŒãŒä¿®æ­£ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚</p>

  <div id="test-results"></div>

  <script>
    // Mock jsPsych data structure with empty search data
    const emptyMockJsPsychData = {
      filter: function(criteria) {
        if (criteria.task === 'visual_search') {
          return {
            count: () => 0, // No search data
            filter: (innerCriteria) => ({
              count: () => 0
            }),
            select: (field) => ({
              values: [] // Empty array
            })
          };
        }
        return this;
      },
      select: function(field) {
        return { values: [] };
      }
    };

    function runTest(name, testFunction) {
      try {
        const result = testFunction();
        document.getElementById('test-results').innerHTML += 
          `<div class="test-result pass">
            <h3>âœ… ${name}</h3>
            <p>${result}</p>
          </div>`;
      } catch (error) {
        document.getElementById('test-results').innerHTML += 
          `<div class="test-result fail">
            <h3>âŒ ${name}</h3>
            <p>Error: ${error.message}</p>
          </div>`;
      }
    }

    // Test 1: Empty search data should not cause NaN
    runTest('Empty Search Data Test', () => {
      const searchData = emptyMockJsPsychData.filter({task: 'visual_search'});
      const searchTimes = searchData.select('rt').values;
      
      let avgSearchTimeSeconds = 0;
      if (searchTimes && searchTimes.length > 0) {
        const avgSearchTime = searchTimes.reduce((a, b) => a + b, 0) / searchTimes.length;
        avgSearchTimeSeconds = Math.floor((avgSearchTime / 1000) * 100) / 100;
      }
      
      if (isNaN(avgSearchTimeSeconds)) {
        throw new Error('avgSearchTimeSeconds is NaN');
      }
      
      if (avgSearchTimeSeconds !== 0) {
        throw new Error(`Expected 0, got ${avgSearchTimeSeconds}`);
      }
      
      return `Empty data handled correctly: ${avgSearchTimeSeconds} seconds (no NaN)`;
    });

    // Test 2: Null/undefined values in search times
    const corruptMockJsPsychData = {
      filter: function(criteria) {
        if (criteria.task === 'visual_search') {
          return {
            count: () => 3,
            filter: (innerCriteria) => ({
              count: () => 2
            }),
            select: (field) => ({
              values: [2000, null, undefined] // Corrupt data
            })
          };
        }
        return this;
      },
      select: function(field) {
        return { values: [1, 0, undefined] };
      }
    };

    runTest('Corrupt Search Data Test', () => {
      const searchData = corruptMockJsPsychData.filter({task: 'visual_search'});
      const searchTimes = searchData.select('rt').values;
      
      let avgSearchTimeSeconds = 0;
      if (searchTimes && searchTimes.length > 0) {
        // Filter out invalid values first
        const validTimes = searchTimes.filter(time => time != null && !isNaN(time));
        if (validTimes.length > 0) {
          const avgSearchTime = validTimes.reduce((a, b) => a + b, 0) / validTimes.length;
          avgSearchTimeSeconds = Math.floor((avgSearchTime / 1000) * 100) / 100;
        }
      }
      
      if (isNaN(avgSearchTimeSeconds)) {
        throw new Error('avgSearchTimeSeconds is NaN');
      }
      
      const expectedTime = Math.floor((2000 / 1000) * 100) / 100; // 2.00 seconds
      if (avgSearchTimeSeconds !== expectedTime) {
        throw new Error(`Expected ${expectedTime}, got ${avgSearchTimeSeconds}`);
      }
      
      return `Corrupt data handled correctly: ${avgSearchTimeSeconds} seconds (filtered invalid values)`;
    });

    // Test 3: Test truncation behavior with various decimal values
    runTest('Truncation Behavior Test', () => {
      const testCases = [
        { input: 2.567, expected: 2.56 },
        { input: 2.999, expected: 2.99 },
        { input: 2.001, expected: 2.00 },
        { input: 1.0, expected: 1.00 },
        { input: 3.14159, expected: 3.14 }
      ];
      
      const results = [];
      for (const testCase of testCases) {
        const result = Math.floor(testCase.input * 100) / 100;
        if (result !== testCase.expected) {
          throw new Error(`For ${testCase.input}, expected ${testCase.expected}, got ${result}`);
        }
        results.push(`${testCase.input} â†’ ${result}`);
      }
      
      return `All truncation tests passed: ${results.join(', ')}`;
    });

    document.getElementById('test-results').innerHTML += 
      `<div class="test-result">
        <h3>ğŸ“ ãƒ†ã‚¹ãƒˆå®Œäº†</h3>
        <p>NaNå•é¡ŒãŒä¿®æ­£ã•ã‚Œã€å°æ•°ç‚¹2æ¡ã¸ã®åˆ‡ã‚Šæ¨ã¦ãŒæ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™ã€‚</p>
        <p><strong>ä¿®æ­£å†…å®¹:</strong></p>
        <ul>
          <li>ç©ºã®æ¤œç´¢ãƒ‡ãƒ¼ã‚¿ã§ã‚‚NaNã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãªã„</li>
          <li>null/undefinedå€¤ã‚’é©åˆ‡ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°</li>
          <li>å°æ•°ç‚¹ç¬¬3ä½ä»¥é™ã‚’åˆ‡ã‚Šæ¨ã¦ï¼ˆ2.999 â†’ 2.99ï¼‰</li>
          <li>Math.floor()ã‚’ä½¿ç”¨ã—ãŸæ­£ç¢ºãªåˆ‡ã‚Šæ¨ã¦å‡¦ç†</li>
        </ul>
      </div>`;
  </script>
</body>
</html>
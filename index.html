<!DOCTYPE html>
<html>
<head>
  <title>visual search task</title>
  <script src="https://unpkg.com/jspsych@7"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-instructions@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://unpkg.com/jspsych@7/css/jspsych.css" rel="stylesheet" type="text/css" />
  <link href="styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Create required DOM elements for cognition.run deployment
    const targetDiv = document.createElement('div');
    targetDiv.id = 'jspsych-target';
    document.body.appendChild(targetDiv);

    const canvas = document.createElement('canvas');
    canvas.id = 'jspsych-visual-search-canvas';
    canvas.classList.add('hidden');
    document.body.appendChild(canvas);

    const searchWindowDiv = document.createElement('div');
    searchWindowDiv.id = 'search-window';
    searchWindowDiv.classList.add('hidden');
    document.body.appendChild(searchWindowDiv);

    // Initialize jsPsych v7 instance (upgraded from v6.3.1)
    // Note: Targeting v7.x as the latest stable version (v8.x may not be available yet)
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: function() {
        jsPsych.data.displayData();
      },
      on_trial_start: function() {
        // 各試行の開始時に、実験がフルスクリーンモードであることを確認
        if (!document.fullscreenElement && 
            !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && 
            !document.msFullscreenElement) {
          // フルスクリーンではない場合、再度要求（ブラウザによってはユーザー操作が必要）
          console.log("フルスクリーンモードの再確認");
        }
      }
    });

    // Automatically capture participant's screen resolution
    jsPsych.data.addProperties({
      screen_width: window.screen.width,
      screen_height: window.screen.height
    });

    // フルスクリーンモードを要求する関数
    function enterFullscreen() {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen().then(() => {
          console.log("フルスクリーンモードに正常に移行しました");
        }).catch(err => {
          console.warn("フルスクリーン移行エラー:", err);
        });
      } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      }
      
      // フォーカス管理を改善 - フォームの邪魔をしないようにする
      // setTimeout(() => {
      //   if (document.getElementById('jspsych-target')) {
      //     document.getElementById('jspsych-target').focus();
      //   }
      // }, 100);
    }

    // 実験開始時にフルスクリーンモードに自動的に移行するよう設定
    // ブラウザのセキュリティ制限のため、何らかのユーザー操作（キー入力など）に応じて実行する必要がある

    // ブラウザテスト用のデバッグ関数 (削除済み - イベントリスナーの競合を避けるため)
    // function testBrowserInteraction() {
    //   console.log("ブラウザテスト: キー入力のテスト");
    //   
    //   // キーボード入力のテスト
    //   window.addEventListener('keydown', function(e) {
    //     console.log("キー入力を検出:", e.key);
    //   });
    //   
    //   // カーソル操作のテスト
    //   document.addEventListener('mousemove', function(e) {
    //     // 大量のログを避けるため、100px移動ごとにログ
    //     if (e.clientX % 100 < 5 && e.clientY % 100 < 5) {
    //       console.log("カーソル位置:", e.clientX, e.clientY);
    //     }
    //   });
    //   
    //   console.log("ブラウザテスト: フルスクリーンの状態");
    //   if (document.fullscreenElement || 
    //       document.webkitFullscreenElement || 
    //       document.mozFullScreenElement || 
    //       document.msFullscreenElement) {
    //     console.log("現在フルスクリーンモード");
    //   } else {
    //     console.log("フルスクリーンモードではない");
    //   }
    // }
    
    // 実験開始時にテスト関数を実行 (削除済み)
    // window.addEventListener('load', function() {
    //   setTimeout(testBrowserInteraction, 2000);
    // });

    // Fullscreen management - only add listeners when needed to avoid conflicts with forms
    let fullscreenListenersActive = false;
    
    function addFullscreenListeners() {
      if (!fullscreenListenersActive) {
        // Add a small delay to ensure DOM is ready
        setTimeout(() => {
          document.addEventListener('fullscreenchange', handleFullscreenChange);
          document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
          document.addEventListener('mozfullscreenchange', handleFullscreenChange);
          document.addEventListener('MSFullscreenChange', handleFullscreenChange);
          fullscreenListenersActive = true;
        }, 50);
      }
    }
    
    function removeFullscreenListeners() {
      if (fullscreenListenersActive) {
        document.removeEventListener('fullscreenchange', handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
        document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
        fullscreenListenersActive = false;
      }
    }

    function handleFullscreenChange() {
      try {
        if (document.fullscreenElement || 
            document.webkitFullscreenElement || 
            document.mozFullScreenElement || 
            document.msFullscreenElement) {
          console.log("フルスクリーンモードに切り替わりました");
        } else {
          console.log("フルスクリーンモードから抜けました");
        }
      } catch (error) {
        console.warn("フルスクリーン状態の確認中にエラーが発生しました:", error);
      }
    }

    // Experiment parameters
    const params = {
      // Screen dimensions (will be updated at runtime)
      screenWidth: window.innerWidth,
      screenHeight: window.innerHeight,
      
      // Window dimensions (approximately 1/9 of screen)
      windowWidth: Math.floor(window.innerWidth / 3),
      windowHeight: Math.floor(window.innerHeight / 3),
      
      // Objects
      numObjects: 25, // Total number of objects per trial
      objectSize: 40, // Fixed size for all objects
      
      // Target detection tolerance
      targetTolerance: 0.8, // Additional tolerance as multiplier of object size (0.8 = 80% of object size)
      
      // Colors and shapes
      colors: ['red', 'blue', 'green', 'yellow', 'purple'],
      shapes: ['circle', 'triangle', 'square', 'diamond'],
      
      // Trials
      trialsPerCondition: 10,
      
      // Memory task
      memoryGridSize: 4, // 4x4 grid
      memoryPositions: 3, // Number of positions to remember
    };

    // Generate random object size within the specified range
    // Get fixed object size (all objects use the same size defined in params.objectSize)
    // All objects are consistently 40px in size
    function getObjectSize() {
      return params.objectSize;
    }

    // Get a representative size for target presentation (same as search objects)
    function getTargetPresentationSize() {
      return params.objectSize; // Same as search objects - 40px
    }

    // Trial factors
    const factors = {
      viewCondition: ['window', 'scroll', 'fullscreen'],
      structure: ['structured', 'unstructured'],
      memoryLoad: ['with-memory', 'without-memory']
    };

    // Track mouse movements
    let mouseX = 0;
    let mouseY = 0;
    let mousePath = [];
    let totalMovement = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let isMouseDown = false;
    let currentDragDistance = 0; // Track drag distance for current interaction
    let justFinishedDrag = false; // Track if a drag operation just finished
    let dragOffsetX = 0; // Offset between cursor and window left edge when drag starts
    let dragOffsetY = 0; // Offset between cursor and window top edge when drag starts

    // Target and distractor objects
    let objects = [];
    let targetObject = null;

    // Memory task variables
    let memoryPositions = [];
    let selectedMemoryPositions = [];

    // Trial progress tracking variables
    let currentMainTrialNumber = 0;
    const totalMainTrials = 120; // 3 viewConditions × 2 structures × 10 trialsPerCondition × 2 blocks

    // Welcome screen
    const welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-6">
          <div class="bg-white rounded-xl shadow-lg p-8 max-w-2xl w-full text-center">
            <div class="mb-8">
              <svg class="w-16 h-16 mx-auto mb-4 text-indigo-600" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd" />
              </svg>
            </div>
            <h1 class="text-3xl font-bold text-gray-800 mb-6">視覚探索実験へようこそ</h1>
            <p class="text-lg text-gray-600 mb-8 leading-relaxed">
              この度は実験にご参加いただき、誠にありがとうございます。<br>
              約30分の心理学実験にお付き合いください。
            </p>
            <div class="bg-blue-50 border-l-4 border-blue-400 p-4 mb-8 text-left">
              <div class="flex">
                <div class="flex-shrink-0">
                  <svg class="h-5 w-5 text-blue-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                  </svg>
                </div>
                <div class="ml-3">
                  <p class="text-sm text-blue-700">
                    実験は集中できる静かな環境で行ってください。途中での中断も可能です。
                  </p>
                </div>
              </div>
            </div>
            <button id="welcome-next-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-8 rounded-lg transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
              実験を開始する
            </button>
          </div>
        </div>
      `,
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during welcome
        removeFullscreenListeners();
        
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('welcome-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Informed consent screen
    const informedConsent = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = `
          <div class="min-h-screen bg-gradient-to-br from-slate-50 to-gray-100 p-6">
            <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-8">
              <div class="text-center mb-8">
                <div class="inline-flex items-center justify-center w-12 h-12 bg-slate-100 rounded-lg mb-4">
                  <svg class="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                  </svg>
                </div>
                <h1 class="text-3xl font-bold text-gray-800 mb-2">研究に関する同意事項</h1>
                <p class="text-gray-600">実験参加前に必ずお読みください</p>
              </div>
              
              <div id="consent-content" class="max-h-96 overflow-y-auto border border-gray-200 rounded-lg p-6 mb-8 bg-gray-50 text-left space-y-6">`;
        
        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-blue-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">1</span>
                    研究の目的
                  </h3>
                  <p class="text-gray-700 leading-relaxed">本研究は、制限された視野を移動して行う視覚探索場面において、視覚的ワーキングメモリおよび物体の配置構造が探索効率に与える影響を解明することを目的とします。</p>
                </div>`;
        
        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-green-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-green-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">2</span>
                    実験内容
                  </h3>
                  <ul class="text-gray-700 leading-relaxed space-y-2">
                    <li class="flex items-start"><span class="text-green-500 mr-2">•</span>実施場所：実験に集中できる環境（Zoom でオンラインセッションを行います）</li>
                    <li class="flex items-start"><span class="text-green-500 mr-2">•</span>所要時間：約 30 分（説明等を含む）</li>
                    <li class="flex items-start"><span class="text-green-500 mr-2">•</span>課題内容：ご自身の PC からアクセスしていただき、画面上に表示される特定の図形の場所を探す課題に、繰り返し取り組んでいただきます。</li>
                    <li class="flex items-start"><span class="text-green-500 mr-2">•</span>収集するデータ：氏名、メールアドレス（謝礼支払い目的のみ）、性別、年齢、反応時間、課題の成績、カーソルの移動履歴</li>
                  </ul>
                </div>`;
        
        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-orange-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-orange-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">3</span>
                    参加条件
                  </h3>
                  <ul class="text-gray-700 leading-relaxed space-y-2">
                    <li class="flex items-start"><span class="text-orange-500 mr-2">•</span>18 歳以上の方。</li>
                    <li class="flex items-start"><span class="text-orange-500 mr-2">•</span>正常または矯正視力を有し、課題の理解に支障がない方。</li>
                    <li class="flex items-start"><span class="text-orange-500 mr-2">•</span>静かで落ち着いた場所から自身のパソコンを使って、オンラインで実験に参加できる方。</li>
                  </ul>
                </div>`;

        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-red-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">4</span>
                    予想される不利益・リスクと対処
                  </h3>
                  <ul class="text-gray-700 leading-relaxed space-y-2">
                    <li class="flex items-start"><span class="text-red-500 mr-2">•</span>画面注視による目の疲れ、ストレス等が生じる可能性があります。</li>
                    <li class="flex items-start"><span class="text-red-500 mr-2">•</span>不快・体調不良時はいつでも中断・中止できます。</li>
                  </ul>
                </div>`;

        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-purple-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-purple-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">5</span>
                    研究成果の公開
                  </h3>
                  <p class="text-gray-700 leading-relaxed">この研究の成果は、博士論文および心理系の学会で発表を行う予定です。その際に収集したデータを公開することがありますが、情報から個人が特定されない形式での公開を行います。</p>
                </div>`;

        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-indigo-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-indigo-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">6</span>
                    謝礼・費用
                  </h3>
                  <ul class="text-gray-700 leading-relaxed space-y-2">
                    <li class="flex items-start"><span class="text-indigo-500 mr-2">•</span>謝礼として、PayPayなどに交換可能なデジタルギフト「デジコ」を 300 円分お支払いいたします。</li>
                    <li class="flex items-start"><span class="text-indigo-500 mr-2">•</span>「デジコ」のお支払いに必要なため、氏名とメールアドレスをご回答いただきます。</li>
                    <li class="flex items-start"><span class="text-indigo-500 mr-2">•</span>参加に費用はかかりません（通信費等は参加者負担となります）。</li>
                  </ul>
                </div>`;

        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-teal-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-teal-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">7</span>
                    任意参加・撤回の自由
                  </h3>
                  <ul class="text-gray-700 leading-relaxed space-y-2">
                    <li class="flex items-start"><span class="text-teal-500 mr-2">•</span>参加は完全に任意です。また理由を問わず、途中で撤回できます。</li>
                    <li class="flex items-start"><span class="text-teal-500 mr-2">•</span>参加を撤回した場合や途中で中止とした場合にも、不利益は一切ありません。</li>
                  </ul>
                </div>`;

        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-cyan-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-cyan-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">8</span>
                    個人情報とデータの取扱い
                  </h3>
                  <ul class="text-gray-700 leading-relaxed space-y-2">
                    <li class="flex items-start"><span class="text-cyan-500 mr-2">•</span>データは ID で管理し、氏名等の識別情報と分離して保管します。</li>
                    <li class="flex items-start"><span class="text-cyan-500 mr-2">•</span>データは研究実施者および指導教員のみが閲覧可能な状態で保存します。</li>
                    <li class="flex items-start"><span class="text-cyan-500 mr-2">•</span>データの第三者提供は原則行いません。学会・論文等では統計的に集計した形で公表します。</li>
                    <li class="flex items-start"><span class="text-cyan-500 mr-2">•</span>実験実施上で得られた個人情報等は、すべて守秘をお約束し、外部から閲覧不可の状態で厳重に管理いたします。</li>
                  </ul>
                </div>`;

        html += `
                <div class="bg-white p-4 rounded-lg border-l-4 border-slate-500">
                  <h3 class="text-lg font-semibold text-gray-800 mb-2 flex items-center">
                    <span class="bg-slate-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm mr-3">9</span>
                    お問い合わせ先
                  </h3>
                  <div class="text-gray-700 leading-relaxed space-y-3">
                    <div class="bg-gray-50 p-3 rounded">
                      <p class="font-semibold">研究実施者：</p>
                      <p>野﨑 優晴（東京学芸大学大学院 連合学校教育学研究科 博士課程）</p>
                      <p class="text-blue-600">E-mail：r241004y@st.u-gakugei.ac.jp</p>
                    </div>
                    <div class="bg-gray-50 p-3 rounded">
                      <p class="font-semibold">指導教員：</p>
                      <p>関口 貴裕（東京学芸大学 教育心理学講座 教授）</p>
                      <p class="text-blue-600">E-mail：sekiguti@u-gakugei.ac.jp</p>
                    </div>
                  </div>
                </div>`;
        
        html += '</div>'; // End of scrollable content
        
        // Consent checkbox and button
        html += `
              <div class="text-center border-t pt-6">
                <label class="inline-flex items-center mb-6 cursor-pointer">
                  <input type="checkbox" id="consent-checkbox" class="w-5 h-5 text-slate-600 border-gray-300 rounded focus:ring-slate-500 focus:ring-2">
                  <span class="ml-3 text-lg text-gray-700 font-medium">上記の内容を確認し、研究参加に同意します</span>
                </label>
                <div>
                  <button id="consent-next-btn" disabled class="bg-gray-300 text-gray-500 font-semibold py-3 px-8 rounded-lg cursor-not-allowed transition duration-200 disabled:transform-none">
                    次へ進む
                  </button>
                </div>
              </div>
            </div>
          </div>
        `;
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during consent
        removeFullscreenListeners();
        
        const checkbox = document.getElementById('consent-checkbox');
        const nextBtn = document.getElementById('consent-next-btn');
        
        // Enable/disable button based on checkbox state
        checkbox.addEventListener('change', function() {
          if (checkbox.checked) {
            nextBtn.disabled = false;
            nextBtn.className = 'bg-slate-600 hover:bg-slate-700 text-white font-semibold py-3 px-8 rounded-lg cursor-pointer transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-offset-2';
          } else {
            nextBtn.disabled = true;
            nextBtn.className = 'bg-gray-300 text-gray-500 font-semibold py-3 px-8 rounded-lg cursor-not-allowed transition duration-200 disabled:transform-none';
          }
        });
        
        // Add click event listener to the Next button
        nextBtn.addEventListener('click', function() {
          if (checkbox.checked) {
            // Record consent in jsPsych data
            jsPsych.data.addProperties({
              informed_consent: true,
              consent_timestamp: new Date().toISOString()
            });
            jsPsych.finishTrial();
          }
        });
      }
    };

    // Combined demographic information - Name, Email, Age, and Gender
    const demographics = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = `
          <div class="min-h-screen bg-gradient-to-br from-emerald-50 to-teal-100 flex items-center justify-center p-6">
            <div class="bg-white rounded-xl shadow-lg p-8 max-w-2xl w-full">
              <div class="text-center mb-8">
                <div class="inline-flex items-center justify-center w-12 h-12 bg-emerald-100 rounded-lg mb-4">
                  <svg class="w-6 h-6 text-emerald-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                  </svg>
                </div>
                <h2 class="text-3xl font-bold text-gray-800 mb-2">基本情報の入力</h2>
                <p class="text-gray-600">実験参加に必要な情報をご入力ください</p>
              </div>
              
              <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-8">
                <div class="flex">
                  <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-amber-400" viewBox="0 0 20 20" fill="currentColor">
                      <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                  </div>
                  <div class="ml-3">
                    <h4 class="text-sm font-medium text-amber-800 mb-1">個人情報の取り扱いについて</h4>
                    <div class="text-sm text-amber-700 space-y-1">
                      <p><strong>氏名・メールアドレス</strong>は謝礼のお支払い目的のみに利用し、実験データとは分離して管理いたします。</p>
                      <p>謝礼のお支払いのため、入力いただいたアドレスに後日ご連絡いたします。</p>
                    </div>
                  </div>
                </div>
              </div>
              
              <form id="demographics-form" class="space-y-6">
                <div>
                  <label for="name-input" class="block text-sm font-semibold text-gray-700 mb-2">
                    氏名 <span class="text-red-500">*</span>
                  </label>
                  <input 
                    type="text" 
                    id="name-input" 
                    name="name" 
                    required 
                    class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 transition duration-200" 
                    placeholder="お名前を入力してください"
                  >
                </div>
                
                <div>
                  <label for="email-input" class="block text-sm font-semibold text-gray-700 mb-2">
                    メールアドレス <span class="text-red-500">*</span>
                  </label>
                  <input 
                    type="email" 
                    id="email-input" 
                    name="email" 
                    required 
                    class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 transition duration-200" 
                    placeholder="example@example.com"
                  >
                  <p class="mt-1 text-sm text-gray-500">r241004y@st.u-gakugei.ac.jp からの連絡を受信できるアドレスをご入力ください</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label for="age-select" class="block text-sm font-semibold text-gray-700 mb-2">
                      年齢 <span class="text-red-500">*</span>
                    </label>
                    <select 
                      id="age-select" 
                      name="age" 
                      required 
                      class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 transition duration-200"
                    >
                      <option value="">選択してください</option>`;

        // Generate age options from 18 to 100
        for (let i = 18; i <= 100; i++) {
          html += `<option value="${i}">${i}歳</option>`;
        }
        
        html += `
                    </select>
                  </div>
                  
                  <div>
                    <label for="gender-select" class="block text-sm font-semibold text-gray-700 mb-2">
                      性別 <span class="text-red-500">*</span>
                    </label>
                    <select 
                      id="gender-select" 
                      name="gender" 
                      required 
                      class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 transition duration-200"
                    >
                      <option value="">選択してください</option>
                      <option value="男性">男性</option>
                      <option value="女性">女性</option>
                      <option value="その他">その他</option>
                    </select>
                  </div>
                </div>
                
                <div class="pt-6 text-center">
                  <button 
                    type="submit" 
                    class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-3 px-8 rounded-lg transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2"
                  >
                    次へ進む
                  </button>
                </div>
              </form>
            </div>
          </div>
        `;
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during demographics
        removeFullscreenListeners();
        
        const form = document.getElementById('demographics-form');
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          
          const nameInput = document.getElementById('name-input');
          const emailInput = document.getElementById('email-input');
          const ageSelect = document.getElementById('age-select');
          const genderSelect = document.getElementById('gender-select');
          
          const name = nameInput.value.trim();
          const email = emailInput.value.trim();
          const age = ageSelect.value;
          const gender = genderSelect.value;
          
          // Validate all fields
          if (!name) {
            alert('氏名を入力してください。');
            nameInput.focus();
            return;
          }
          
          if (!email) {
            alert('メールアドレスを入力してください。');
            emailInput.focus();
            return;
          }
          
          // Basic email validation
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(email)) {
            alert('有効なメールアドレスを入力してください。');
            emailInput.focus();
            return;
          }
          
          if (!age) {
            alert('年齢を選択してください。');
            ageSelect.focus();
            return;
          }
          
          if (!gender) {
            alert('性別を選択してください。');
            genderSelect.focus();
            return;
          }
          
          // Store all demographic data
          jsPsych.data.addProperties({
            participant_name: name,
            participant_email: email,
            age: age,
            gender: gender
          });
          
          // Finish the trial with the collected data
          jsPsych.finishTrial({
            participant_name: name,
            participant_email: email,
            age: age,
            gender: gender
          });
        });
      }
    };
          });
        });
      },
      on_finish: function() {
        // After demographics are complete, activate fullscreen
        setTimeout(() => {
          addFullscreenListeners();
          enterFullscreen();
        }, 100);
      }
    };

    // Comprehensive experiment instruction screen (updated according to wireframe ①)
    const experimentInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = `
          <div class="min-h-screen bg-gradient-to-br from-purple-50 to-indigo-100 p-6">
            <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-8">
              <div class="text-center mb-8">
                <div class="inline-flex items-center justify-center w-16 h-16 bg-purple-100 rounded-lg mb-4">
                  <svg class="w-8 h-8 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                  </svg>
                </div>
                <h1 class="text-4xl font-bold text-gray-800 mb-4">実験の操作説明</h1>
                <p class="text-lg text-gray-600">実験の流れと操作方法について説明します</p>
              </div>
              
              <div class="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg p-6 mb-8">
                <div class="flex items-center mb-4">
                  <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center mr-3">
                    <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                      <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                    </svg>
                  </div>
                  <h2 class="text-xl font-semibold text-blue-800">実験全体の流れ</h2>
                </div>
                <div class="space-y-3 text-blue-700">
                  <p class="text-lg">まず、画面中央に1秒だけ図形が表示されるので、覚えてください。次に、たくさんの図形が表示されるので、覚えた図形を探してクリックしてください。</p>
                  <p class="text-lg">できるだけ<span class="font-bold text-red-600">早く</span>、<span class="font-bold text-red-600">正確に</span>探してください。</p>
                  <p class="text-lg">全部終了すると、あなたのスコアが表示されます。</p>
                </div>
              </div>
              
              <div class="mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                  <span class="w-6 h-6 bg-green-500 rounded-full text-white flex items-center justify-center text-sm mr-3">✓</span>
                  実験の構成
                </h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">`;
        
        const steps = [
          { num: '1', title: '練習', desc: '9回', detail: 'まずは操作に慣れましょう', color: 'from-blue-500 to-blue-600' },
          { num: '2', title: '前半', desc: '60回', detail: '集中してがんばりましょう', color: 'from-purple-500 to-purple-600' },
          { num: '3', title: '後半', desc: '60回', detail: '記憶課題も追加されます', color: 'from-indigo-500 to-indigo-600' }
        ];
        
        steps.forEach(step => {
          html += `
            <div class="bg-gradient-to-r ${step.color} text-white p-6 rounded-lg text-center transform hover:scale-105 transition duration-200">
              <div class="text-3xl font-bold mb-2">${step.num}</div>
              <div class="text-xl font-semibold mb-2">${step.title}</div>
              <div class="text-lg mb-2">${step.desc}</div>
              <div class="text-sm opacity-90">${step.detail}</div>
            </div>
          `;
        });
        
        html += `
                </div>
              </div>
              
              <div class="mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                  <span class="w-6 h-6 bg-red-500 rounded-full text-white flex items-center justify-center text-sm mr-3">!</span>
                  操作の説明
                </h2>
                <div class="space-y-4">`;
        
        const taskSteps = [
          { step: '1', text: '条件の説明が表示されます' },
          { step: '2', text: '1秒間だけターゲットが表示されます。集中して見て覚えてください。' },
          { step: '3', text: '図形を探す画面が表示されます。図形を探す画面は3パターンあり、ランダムでどれかが表示されます。' },
          { step: '4', text: 'これを何度も繰り返します。集中力を切らさないように頑張ってください。' }
        ];
        
        taskSteps.forEach(task => {
          html += `
            <div class="bg-white border-2 border-gray-200 rounded-lg p-4 flex items-start space-x-4 hover:border-red-300 transition duration-200">
              <div class="w-8 h-8 bg-red-500 text-white rounded-full flex items-center justify-center font-bold flex-shrink-0">${task.step}</div>
              <div class="text-gray-700 flex-1">${task.text}</div>
            </div>
          `;
        });
        
        html += `
                </div>
              </div>
              
              <div class="mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                  <span class="w-6 h-6 bg-purple-500 rounded-full text-white flex items-center justify-center text-sm mr-3">3</span>
                  3つの表示パターン
                </h2>
                <div class="space-y-4">`;
        
        const conditions = [
          {
            name: '全画面',
            color: 'blue',
            bgColor: 'bg-blue-50',
            borderColor: 'border-blue-300',
            textColor: 'text-blue-800',
            description: '覚えた図形を探してクリックしてください。'
          },
          {
            name: 'ウィンドウ', 
            color: 'orange',
            bgColor: 'bg-orange-50',
            borderColor: 'border-orange-300',
            textColor: 'text-orange-800',
            description: 'ウィンドウが表示されます。ウィンドウをドラッグすることで、隠れている範囲も見ることができます。覚えた図形を見つけたらクリックしてください。'
          },
          {
            name: 'スクロール',
            color: 'green',
            bgColor: 'bg-green-50',
            borderColor: 'border-green-300',
            textColor: 'text-green-800',
            description: 'ウィンドウが中央に固定されています。ドラッグすると背景がスクロールされるので、覚えた図形を探し、見つけたらクリックしてください。'
          }
        ];
        
        conditions.forEach((condition, index) => {
          html += `
            <div class="${condition.bgColor} ${condition.borderColor} border-2 rounded-lg p-6">
              <h3 class="${condition.textColor} text-xl font-semibold mb-3 flex items-center">
                <span class="w-7 h-7 bg-${condition.color}-500 text-white rounded-full flex items-center justify-center text-sm mr-3">${index + 1}</span>
                ${condition.name}
              </h3>
              <p class="text-gray-700 leading-relaxed">${condition.description}</p>
            </div>
          `;
        });
        
        html += `
                </div>
              </div>
              
              <div class="bg-gradient-to-r from-yellow-50 to-amber-50 border-2 border-amber-300 rounded-lg p-6 mb-8 text-center">
                <div class="flex items-center justify-center mb-4">
                  <div class="w-10 h-10 bg-amber-400 rounded-full flex items-center justify-center">
                    <span class="text-xl">⚡</span>
                  </div>
                </div>
                <h3 class="text-xl font-bold text-amber-800 mb-3">重要なポイント</h3>
                <p class="text-lg font-semibold text-amber-700">できるだけ早く、正確に図形を見つけてクリックしてください</p>
              </div>
              
              <div class="text-center pt-6">
                <button id="instructions-continue-btn" class="bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-bold py-4 px-8 rounded-lg text-xl transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 shadow-lg">
                  練習を開始する
                </button>
              </div>
            </div>
          </div>
        `;
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Ensure no fullscreen listeners are active during instructions
        removeFullscreenListeners();
        
        // Add click event listener to continue button
        const continueBtn = document.getElementById('instructions-continue-btn');
        continueBtn.addEventListener('click', function() {
          jsPsych.finishTrial({
            user_action: 'continue_to_practice'
          });
        });
      }
    };

    // Practice explanation screen
    const practiceExplanation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="min-h-screen bg-gradient-to-br from-cyan-50 to-blue-100 flex items-center justify-center p-6">
          <div class="bg-white rounded-xl shadow-lg p-8 max-w-xl w-full text-center">
            <div class="mb-8">
              <div class="inline-flex items-center justify-center w-16 h-16 bg-cyan-100 rounded-lg mb-4">
                <svg class="w-8 h-8 text-cyan-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                </svg>
              </div>
              <h2 class="text-3xl font-bold text-gray-800 mb-4">練習セッション</h2>
              <p class="text-lg text-gray-600">本番前に操作に慣れていただきます</p>
            </div>
            
            <div class="bg-cyan-50 border border-cyan-200 rounded-lg p-6 mb-8">
              <div class="flex items-center justify-center mb-4">
                <div class="w-12 h-12 bg-cyan-500 text-white rounded-full flex items-center justify-center text-2xl font-bold">9</div>
              </div>
              <p class="text-cyan-800 text-lg font-medium">はじめに9回練習を行います</p>
              <p class="text-cyan-700 mt-2">操作方法を覚えて、本番に備えましょう</p>
            </div>
            
            <div class="space-y-4 mb-8 text-left">
              <div class="flex items-center space-x-3">
                <div class="w-6 h-6 bg-green-500 rounded-full flex items-center justify-center">
                  <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                  </svg>
                </div>
                <span class="text-gray-700">練習では正解・不正解のフィードバックがあります</span>
              </div>
              <div class="flex items-center space-x-3">
                <div class="w-6 h-6 bg-green-500 rounded-full flex items-center justify-center">
                  <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                  </svg>
                </div>
                <span class="text-gray-700">リラックスして操作に慣れてください</span>
              </div>
              <div class="flex items-center space-x-3">
                <div class="w-6 h-6 bg-green-500 rounded-full flex items-center justify-center">
                  <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                  </svg>
                </div>
                <span class="text-gray-700">準備ができたら下のボタンをクリック</span>
              </div>
            </div>
            
            <button id="practice-next-btn" class="bg-cyan-600 hover:bg-cyan-700 text-white font-semibold py-3 px-8 rounded-lg transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-offset-2">
              練習を開始する
            </button>
          </div>
        </div>
      `,
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('practice-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Instructions for visual search task
    const visualSearchInstructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        const viewCondition = jsPsych.timelineVariable('viewCondition');
        const isPractice = jsPsych.timelineVariable('isPractice') || false;
        
        // Define colors for each condition
        const conditionStyles = {
          fullscreen: {
            gradient: 'from-blue-50 to-blue-100',
            bg: 'bg-blue-50',
            border: 'border-blue-300',
            text: 'text-blue-800',
            button: 'bg-blue-600 hover:bg-blue-700',
            icon: 'text-blue-600',
            name: '全画面条件',
            description: '全画面で探索をします'
          },
          window: {
            gradient: 'from-orange-50 to-orange-100',
            bg: 'bg-orange-50',
            border: 'border-orange-300',
            text: 'text-orange-800',
            button: 'bg-orange-600 hover:bg-orange-700',
            icon: 'text-orange-600',
            name: 'ウィンドウ条件',
            description: 'ウィンドウを動かして探索します。'
          },
          scroll: {
            gradient: 'from-green-50 to-green-100',
            bg: 'bg-green-50',
            border: 'border-green-300',
            text: 'text-green-800',
            button: 'bg-green-600 hover:bg-green-700',
            icon: 'text-green-600',
            name: 'スクロール条件',
            description: '背景をスクロールして探索します。'
          }
        };
        
        const style = conditionStyles[viewCondition];
        
        // Generate progress display for main trials only
        let progressDisplay = '';
        if (!isPractice) {
          // Increment trial counter for main trials
          currentMainTrialNumber++;
          progressDisplay = `
            <div class="mb-4 text-center">
              <div class="inline-flex items-center px-4 py-2 bg-gray-100 rounded-full">
                <span class="text-sm font-medium text-gray-600">進捗：</span>
                <span class="ml-2 text-lg font-bold text-gray-800">${currentMainTrialNumber}</span>
                <span class="text-sm text-gray-600">/</span>
                <span class="text-sm text-gray-600">${totalMainTrials}回</span>
              </div>
            </div>
          `;
        }
        
        const conditionIcon = viewCondition === 'fullscreen' ? 
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>' :
          viewCondition === 'window' ? 
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 0v10a2 2 0 01-2 2H9V7z"></path>' :
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>';
        
        return `
          <div class="min-h-screen bg-gradient-to-br ${style.gradient} flex items-center justify-center p-6">
            <div class="bg-white rounded-xl shadow-lg p-8 max-w-lg w-full text-center">
              ${progressDisplay}
              <div class="mb-6">
                <div class="inline-flex items-center justify-center w-16 h-16 ${style.bg} rounded-lg mb-4">
                  <svg class="w-8 h-8 ${style.icon}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    ${conditionIcon}
                  </svg>
                </div>
                <h2 class="text-2xl font-bold text-gray-800 mb-2">次の条件</h2>
              </div>
              
              <div class="${style.bg} ${style.border} border-2 rounded-lg p-6 mb-6">
                <h3 class="${style.text} text-xl font-bold mb-2">${style.name}</h3>
                <p class="${style.text}">${style.description}</p>
              </div>
              
              <div class="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-6">
                <p class="text-gray-700 font-medium">準備ができたら下のボタンをクリックして開始してください</p>
              </div>
              
              <button id="visual-search-next-btn" class="${style.button} text-white font-semibold py-3 px-8 rounded-lg transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2">
                開始する
              </button>
            </div>
          </div>
        `;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('visual-search-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Memory grid task - display
    const memoryGridDisplay = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Generate the memory positions to remember
        memoryPositions = [];
        const gridSize = params.memoryGridSize;
        
        // Randomly select positions
        while (memoryPositions.length < params.memoryPositions) {
          const row = Math.floor(Math.random() * gridSize);
          const col = Math.floor(Math.random() * gridSize);
          const position = row * gridSize + col;
          
          // Ensure no duplicates
          if (!memoryPositions.includes(position)) {
            memoryPositions.push(position);
          }
        }
        
        // Create the grid HTML
        let gridHTML = '<h1>記憶課題</h1>';
        gridHTML += '<p>以下のグリッド内の色のついたセルの位置を記憶してください。</p>';
        gridHTML += '<div id="memory-grid">';
        
        for (let i = 0; i < gridSize * gridSize; i++) {
          const isHighlighted = memoryPositions.includes(i);
          gridHTML += `<div class="memory-cell ${isHighlighted ? 'highlighted' : ''}" data-index="${i}"></div>`;
        }
        
        gridHTML += '</div>';
        gridHTML += '<p>3秒間表示された後、自動的に次へ進みます。</p>';
        
        return gridHTML;
      },
      choices: "NO_KEYS",
      trial_duration: 3000, // Display for 3 seconds
      data: {
        task: 'memory_display',
        memory_positions: function() { return memoryPositions; }
      }
    };

    // Memory grid task - recall (reproduction format)
    const memoryGridRecall = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        const gridSize = params.memoryGridSize;
        
        // Create the HTML with a blank interactive grid
        let gridHTML = '<h1>記憶課題 - 回答</h1>';
        gridHTML += '<p>記憶した位置をクリックして再現してください。</p>';
        gridHTML += '<div id="memory-reproduction-grid" class="memory-reproduction-grid">';
        
        for (let i = 0; i < gridSize * gridSize; i++) {
          gridHTML += `<div class="reproduction-cell" data-index="${i}"></div>`;
        }
        
        gridHTML += '</div>';
        gridHTML += '<button id="memory-reset-btn" class="memory-reset-btn">リセット</button>';
        gridHTML += '<button id="memory-submit-btn" class="memory-submit-btn" disabled>決定</button>';
        gridHTML += '<p id="selection-info">3つのセルを選択してください。</p>';
        
        return gridHTML;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Initialize selected positions array
        selectedMemoryPositions = [];
        
        const cells = document.querySelectorAll('.reproduction-cell');
        const submitBtn = document.getElementById('memory-submit-btn');
        const selectionInfo = document.getElementById('selection-info');
        
        // Add click event listeners to all cells
        cells.forEach(cell => {
          cell.addEventListener('click', function() {
            const index = parseInt(this.getAttribute('data-index'));
            const isSelected = this.classList.contains('selected');
            
            // Only allow selection if cell is not already selected and limit not reached
            if (!isSelected && selectedMemoryPositions.length < params.memoryPositions) {
              this.classList.add('selected');
              selectedMemoryPositions.push(index);
            }
            
            // Update UI based on selection count
            const selectedCount = selectedMemoryPositions.length;
            if (selectedCount === params.memoryPositions) {
              submitBtn.disabled = false;
              selectionInfo.textContent = `${selectedCount}つのセルが選択されました。決定ボタンを押してください。`;
            } else {
              submitBtn.disabled = true;
              selectionInfo.textContent = `${selectedCount}つのセルが選択されました。あと${params.memoryPositions - selectedCount}つ選択してください。`;
            }
          });
        });
        
        // Add submit button event listener
        submitBtn.addEventListener('click', function() {
          if (selectedMemoryPositions.length === params.memoryPositions) {
            // Calculate accuracy
            const correctCount = selectedMemoryPositions.filter(pos => memoryPositions.includes(pos)).length;
            const accuracy = correctCount / params.memoryPositions;
            const isCorrect = accuracy === 1.0; // Perfect match required
            
            jsPsych.finishTrial({
              memory_selected_positions: selectedMemoryPositions,
              memory_correct_positions: memoryPositions,
              memory_accuracy: accuracy,
              memory_correct: isCorrect ? 1 : 0
            });
          }
        });
        
        // Add reset button event listener
        const resetBtn = document.getElementById('memory-reset-btn');
        resetBtn.addEventListener('click', function() {
          // Clear all selections
          selectedMemoryPositions = [];
          cells.forEach(cell => {
            cell.classList.remove('selected');
          });
          
          // Update UI
          submitBtn.disabled = true;
          selectionInfo.textContent = `0つのセルが選択されました。あと${params.memoryPositions}つ選択してください。`;
        });
      }
    };

    // Calculate memory task accuracy
    function calculateMemoryAccuracy(correct, selected) {
      let correctCount = 0;
      for (let pos of selected) {
        if (correct.includes(pos)) {
          correctCount++;
        }
      }
      return correctCount / params.memoryPositions;
    }

    // Fixation point display
    const fixationPoint = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="display: flex; align-items: center; justify-content: center; height: 100vh;">
          <div style="font-size: 60px; font-weight: bold; color: black;">+</div>
        </div>
      `,
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: {
        task: 'fixation_point'
      }
    };

    // Blank screen display (500ms white screen)
    const blankScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="display: flex; align-items: center; justify-content: center; height: 100vh; background-color: white;">
        </div>
      `,
      choices: "NO_KEYS",
      trial_duration: 500,
      data: {
        task: 'blank_screen'
      }
    };

    // Display target object
    const showTarget = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Randomly select target color and shape
        const targetColor = jsPsych.randomization.sampleWithoutReplacement(params.colors, 1)[0];
        const targetShape = jsPsych.randomization.sampleWithoutReplacement(params.shapes, 1)[0];
        
        // Store in data for the visual search task
        jsPsych.data.addProperties({
          target_color: targetColor,
          target_shape: targetShape
        });
        
        return `
          <div style="margin: 20px auto; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;">
            <canvas id="target-canvas" width="60" height="60"></canvas>
          </div>
        `;
      },
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: {
        task: 'show_target'
      },
      on_load: function() {
        // Get target information from data
        const data = jsPsych.data.get().last(1).values()[0];
        const targetColor = data.target_color;
        const targetShape = data.target_shape;
        
        // Draw target on canvas using the same method as search objects
        const canvas = document.getElementById('target-canvas');
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw target object at center of canvas using same drawObject function
        drawObject(ctx, 30, 30, getTargetPresentationSize(), targetColor, targetShape);
      }
    };

    // Draw a shape on canvas or SVG
    function drawShape(shape, color, x, y, size) {
      const halfSize = size / 2;
      
      switch (shape) {
        case 'circle':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <circle cx="${halfSize}" cy="${halfSize}" r="${halfSize * 0.8}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'triangle':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <polygon points="${halfSize},${size * 0.2} ${size * 0.2},${size * 0.8} ${size * 0.8},${size * 0.8}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'square':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <rect x="${size * 0.2}" y="${size * 0.2}" width="${size * 0.6}" height="${size * 0.6}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        case 'diamond':
          return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
                    <polygon points="${halfSize},${size * 0.2} ${size * 0.8},${halfSize} ${halfSize},${size * 0.8} ${size * 0.2},${halfSize}" fill="${color}" stroke="black" stroke-width="2" />
                  </svg>`;
        default:
          return `<svg width="${size}" height="${size}"><circle cx="${halfSize}" cy="${halfSize}" r="${halfSize}" fill="${color}" stroke="black" stroke-width="2" /></svg>`;
      }
    }

    // Visual search task
    const visualSearch = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        return `<div id="search-container" style="width: 100vw; height: 100vh;"></div>`;
      },
      choices: "NO_KEYS",
      data: {
        task: 'visual_search'
      },
      on_load: function() {
        // Get trial parameters
        const viewCondition = jsPsych.timelineVariable('viewCondition');
        const structure = jsPsych.timelineVariable('structure');
        
        // Get target information
        const targetColor = jsPsych.data.get().last(1).values()[0].target_color;
        const targetShape = jsPsych.data.get().last(1).values()[0].target_shape;
        
        // Setup canvas
        const canvas = document.getElementById('jspsych-visual-search-canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        canvas.classList.remove('hidden');
        canvas.style.display = 'block';
        canvas.style.cursor = 'pointer'; // Only set cursor during visual search
        canvas.style.zIndex = '20'; // Set higher z-index during visual search
        canvas.style.pointerEvents = 'auto'; // Enable pointer events during visual search
        
        const ctx = canvas.getContext('2d');
        
        // Setup search window for window and scroll conditions
        const searchWindow = document.getElementById('search-window');
        if (viewCondition !== 'fullscreen') {
          searchWindow.style.width = params.windowWidth + 'px';
          searchWindow.style.height = params.windowHeight + 'px';
          searchWindow.classList.remove('hidden');
          searchWindow.style.display = 'block'; // Ensure search window is visible (reset from previous trial)
          // 中央に固定
          searchWindow.style.left = '50%';
          searchWindow.style.top = '50%';
          searchWindow.style.transform = 'translate(-50%, -50%)';
          
          // Enable pointer events for window condition to allow dragging
          if (viewCondition === 'window') {
            searchWindow.style.pointerEvents = 'auto';
          } else {
            searchWindow.style.pointerEvents = 'none';
          }
        }
        
        // Create visual search display
        const searchArea = {
          width: params.screenWidth,
          height: params.screenHeight
        };
        
        // Reset movement tracking
        mousePath = [];
        totalMovement = 0;
        currentDragDistance = 0; // Reset current drag distance for new trial
        justFinishedDrag = false; // Reset drag finish flag for new trial
        lastMouseX = params.screenWidth / 2;
        lastMouseY = params.screenHeight / 2;
        
        // Generate objects
        const isPractice = jsPsych.timelineVariable('isPractice') || false;
        generateObjects(searchArea, targetColor, targetShape, structure, viewCondition, isPractice);
        
        // Initial draw
        drawSearchDisplay(ctx, viewCondition);
        
        // Start timer
        const startTime = performance.now();
        
        // Setup event listeners
        if (viewCondition === 'window') {
          // Window condition - drag to move the window
          searchWindow.addEventListener('mousedown', startWindowDrag);
          document.addEventListener('mousemove', dragWindow);
          document.addEventListener('mouseup', endWindowDrag);
          // Add click event listener to search window for object selection
          searchWindow.addEventListener('click', checkSelection);
        } else if (viewCondition === 'scroll') {
          // Scroll condition - drag the background
          canvas.addEventListener('mousedown', startDrag);
          document.addEventListener('mousemove', dragBackground);
          document.addEventListener('mouseup', endDrag);
        }
        
        // Click to select object (for fullscreen and scroll conditions)
        if (viewCondition !== 'window') {
          canvas.addEventListener('click', checkSelection);
        }
        
        // Event handler functions
        function startWindowDrag(e) {
          // Only start drag if clicking within the window
          isMouseDown = true;
          mouseX = e.clientX;
          mouseY = e.clientY;
          lastMouseX = mouseX;
          lastMouseY = mouseY;
          currentDragDistance = 0; // Reset drag distance for new interaction
          
          // Calculate offset between cursor and window position
          const searchWindow = document.getElementById('search-window');
          const windowRect = searchWindow.getBoundingClientRect();
          
          // Remove CSS transform and set absolute positioning
          searchWindow.style.transform = 'none';
          searchWindow.style.left = windowRect.left + 'px';
          searchWindow.style.top = windowRect.top + 'px';
          
          // Now calculate the offset with the corrected position
          dragOffsetX = mouseX - windowRect.left;
          dragOffsetY = mouseY - windowRect.top;
        }
        
        function dragWindow(e) {
          if (!isMouseDown && viewCondition === 'window') return; // Only move during drag
          
          mouseX = e.clientX;
          mouseY = e.clientY;
          
          if (viewCondition === 'window' && isMouseDown) {
            // Calculate movement distance
            const dx = mouseX - lastMouseX;
            const dy = mouseY - lastMouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Update total movement and path
            totalMovement += distance;
            currentDragDistance += distance; // Track current interaction drag distance
            mousePath.push({x: mouseX, y: mouseY, time: performance.now() - startTime});
            
            // Update last position
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Move the window using the stored offset
            let windowX = mouseX - dragOffsetX;
            let windowY = mouseY - dragOffsetY;
            
            // Keep window within screen bounds
            windowX = Math.max(0, Math.min(windowX, params.screenWidth - params.windowWidth));
            windowY = Math.max(0, Math.min(windowY, params.screenHeight - params.windowHeight));
            
            searchWindow.style.left = windowX + 'px';
            searchWindow.style.top = windowY + 'px';
            
            // Update canvas clip region
            drawSearchDisplay(ctx, viewCondition);
          }
        }
        
        function endWindowDrag() {
          isMouseDown = false;
          // If there was significant drag, mark it to prevent immediate clicks
          if (currentDragDistance > 5) {
            justFinishedDrag = true;
            setTimeout(() => {
              justFinishedDrag = false;
            }, 50); // Small delay to prevent click events immediately after drag
          }
        }
        
        function startDrag(e) {
          isMouseDown = true;
          mouseX = e.clientX;
          mouseY = e.clientY;
          lastMouseX = mouseX;
          lastMouseY = mouseY;
          currentDragDistance = 0; // Reset drag distance for new interaction
        }
        
        function dragBackground(e) {
          if (!isMouseDown && viewCondition === 'scroll') return;
          
          mouseX = e.clientX;
          mouseY = e.clientY;
          
          if (viewCondition === 'scroll' && isMouseDown) {
            // Calculate movement distance
            const dx = mouseX - lastMouseX;
            const dy = mouseY - lastMouseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Update total movement and path
            totalMovement += distance;
            currentDragDistance += distance; // Track current interaction drag distance
            mousePath.push({x: mouseX, y: mouseY, time: performance.now() - startTime});
            
            // Move all objects
            for (let i = 0; i < objects.length; i++) {
              objects[i].x += dx;
              objects[i].y += dy;
            }
            
            // Update last position
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // Redraw
            drawSearchDisplay(ctx, viewCondition);
          }
        }
        
        function endDrag() {
          isMouseDown = false;
        }
        
        function checkSelection(e) {
          const clickX = e.clientX;
          const clickY = e.clientY;
          
          // For scroll/window conditions, check if significant dragging occurred
          // If user dragged more than 5 pixels, don't treat this as a selection click
          if ((viewCondition === 'scroll' || viewCondition === 'window') && (currentDragDistance > 5 || justFinishedDrag)) {
            return; // Ignore click after significant drag or immediately after drag
          }
          
          // Check if click is within visible area for window/scroll conditions
          if (viewCondition !== 'fullscreen') {
            const windowRect = searchWindow.getBoundingClientRect();
            if (clickX < windowRect.left || clickX > windowRect.right || 
                clickY < windowRect.top || clickY > windowRect.bottom) {
              return; // Click outside visible area
            }
          }
          
          // Find clicked object using standard collision detection
          let clickedObject = null;
          
          for (let i = 0; i < objects.length; i++) {
            const obj = objects[i];
            const dx = clickX - obj.x;
            const dy = clickY - obj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= obj.size / 2) {
              clickedObject = obj;
              break;
            }
          }
          
          // If no object was clicked using standard detection, check for expanded target detection
          if (!clickedObject && targetObject) {
            const targetDx = clickX - targetObject.x;
            const targetDy = clickY - targetObject.y;
            const targetDistance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            // Calculate expanded hit radius for target
            const expandedTargetRadius = (targetObject.size / 2) + (targetObject.size * params.targetTolerance);
            
            if (targetDistance <= expandedTargetRadius) {
              clickedObject = targetObject;
            }
          }
          
          // Check if target was found
          const correct = clickedObject === targetObject;
          const rt = performance.now() - startTime;
          
          // Remove event listeners
          if (viewCondition === 'window') {
            searchWindow.removeEventListener('mousedown', startWindowDrag);
            document.removeEventListener('mousemove', dragWindow);
            document.removeEventListener('mouseup', endWindowDrag);
            searchWindow.removeEventListener('click', checkSelection);
            // Reset pointer events for search window
            searchWindow.style.pointerEvents = 'none';
          } else if (viewCondition === 'scroll') {
            canvas.removeEventListener('mousedown', startDrag);
            document.removeEventListener('mousemove', dragBackground);
            document.removeEventListener('mouseup', endDrag);
          }
          
          if (viewCondition !== 'window') {
            canvas.removeEventListener('click', checkSelection);
          }
          
          // Reset drag state
          isMouseDown = false;
          justFinishedDrag = false;
          
          // Hide canvas and window immediately using direct style property
          canvas.style.display = 'none';
          canvas.style.cursor = 'default'; // Reset cursor
          canvas.style.zIndex = '5'; // Reset z-index
          canvas.style.pointerEvents = 'none'; // Disable pointer events
          searchWindow.style.display = 'none';
          
          // Finish trial
          const memoryLoadCondition = jsPsych.timelineVariable('memoryLoad');
          const isPracticeCondition = jsPsych.timelineVariable('isPractice') || false;
          const trialData = {
            reaction_time: rt,
            correct: correct,
            view_condition: viewCondition,
            structure: structure,
            memory_load: memoryLoadCondition,
            wm_load: memoryLoadCondition === 'with-memory', // Boolean indicator for WM load presence
            practice_trial: isPracticeCondition, // Boolean indicator for practice trial
            target_color: targetColor,
            target_shape: targetShape,
            total_movement: totalMovement,
            mouse_path: mousePath,
            task: 'visual_search',
            is_practice: jsPsych.timelineVariable('isPractice') || false
          };
          
          // Only save data if not in practice mode
          if (!jsPsych.timelineVariable('isPractice')) {
            jsPsych.finishTrial(trialData);
          } else {
            // For practice, still finish trial but don't save to main data
            jsPsych.finishTrial(trialData);
          }
        }
      }
    };

    // Generate objects for visual search
    function generateObjects(area, targetColor, targetShape, structure, viewCondition, isPractice) {
      objects = [];
      let positions = [];
      
      // Use fixed object size for positioning calculations (to avoid overlaps)
      const avgObjectSize = params.objectSize;
      
      let targetX, targetY;
      
      // Calculate initial window bounds for practice trials
      let initialWindowBounds = null;
      if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
        // Initial window is centered on screen
        const windowCenterX = params.screenWidth / 2;
        const windowCenterY = params.screenHeight / 2;
        initialWindowBounds = {
          left: windowCenterX - params.windowWidth / 2,
          right: windowCenterX + params.windowWidth / 2,
          top: windowCenterY - params.windowHeight / 2,
          bottom: windowCenterY + params.windowHeight / 2
        };
      }
      
      // Helper function to check if target overlaps with initial window
      function isTargetInInitialWindow(x, y) {
        if (!initialWindowBounds) return false;
        
        // Check if target center is within window bounds
        // Add some padding to account for object size
        const padding = avgObjectSize / 2;
        return (x + padding > initialWindowBounds.left && 
                x - padding < initialWindowBounds.right &&
                y + padding > initialWindowBounds.top && 
                y - padding < initialWindowBounds.bottom);
      }
      
      if (structure === 'structured') {
        // For structured condition, create a grid layout
        const gridSize = Math.floor(Math.sqrt(params.numObjects));
        const cellWidth = area.width / gridSize;
        const cellHeight = area.height / gridSize;
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            positions.push({
              x: i * cellWidth + cellWidth / 2,
              y: j * cellHeight + cellHeight / 2
            });
          }
        }
        
        // For practice trials, filter out positions that would be in the initial window
        let availablePositions = positions;
        if (isPractice && (viewCondition === 'window' || viewCondition === 'scroll')) {
          availablePositions = positions.filter(pos => !isTargetInInitialWindow(pos.x, pos.y));
          
          // If no positions are available outside the window, use all positions as fallback
          if (availablePositions.length === 0) {
            availablePositions = positions;
          }
        }
        
        // Randomly place target at one of the available positions
        const targetPosition = Math.floor(Math.random() * availablePositions.length);
        targetX = availablePositions[targetPosition].x;
        targetY = availablePositions[targetPosition].y;
        
        // Remove the target position from the original positions array
        const originalTargetIndex = positions.findIndex(pos => pos.x === targetX && pos.y === targetY);
        if (originalTargetIndex >= 0) {
          positions.splice(originalTargetIndex, 1);
        }
      } else {
        // Unstructured condition - random positions
        let attempts = 0;
        const maxAttempts = 50; // Prevent infinite loops
        
        do {
          targetX = Math.random() * (area.width - avgObjectSize * 2) + avgObjectSize;
          targetY = Math.random() * (area.height - avgObjectSize * 2) + avgObjectSize;
          attempts++;
        } while (isPractice && (viewCondition === 'window' || viewCondition === 'scroll') && 
                 isTargetInInitialWindow(targetX, targetY) && attempts < maxAttempts);
        
        // Generate random positions for distractors
        for (let i = 0; i < params.numObjects - 1; i++) {
          let x, y, overlapping;
          
          do {
            x = Math.random() * (area.width - avgObjectSize * 2) + avgObjectSize;
            y = Math.random() * (area.height - avgObjectSize * 2) + avgObjectSize;
            
            // Check if too close to target
            const dx = x - targetX;
            const dy = y - targetY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            overlapping = distance < avgObjectSize;
            
            // Check if too close to other positions
            for (let j = 0; j < positions.length && !overlapping; j++) {
              const dx = x - positions[j].x;
              const dy = y - positions[j].y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance < avgObjectSize) {
                overlapping = true;
              }
            }
          } while (overlapping);
          
          positions.push({x: x, y: y});
        }
      }
      
      // Create the target object
      targetObject = {
        x: targetX,
        y: targetY,
        size: getObjectSize(),
        color: targetColor,
        shape: targetShape,
        isTarget: true
      };
      
      objects.push(targetObject);
      
      // Create distractor objects
      for (let i = 0; i < params.numObjects - 1; i++) {
        if (i >= positions.length) break;
        
        let distractorColor, distractorShape;
        
        // Ensure at least one feature is different from target
        if (Math.random() < 0.5) {
          // Different color, same shape
          distractorColor = jsPsych.randomization.sampleWithoutReplacement(
            params.colors.filter(c => c !== targetColor), 1)[0];
          distractorShape = targetShape;
        } else {
          // Same color, different shape
          distractorColor = targetColor;
          distractorShape = jsPsych.randomization.sampleWithoutReplacement(
            params.shapes.filter(s => s !== targetShape), 1)[0];
        }
        
        // Some distractors might differ in both features
        if (Math.random() < 0.3) {
          distractorColor = jsPsych.randomization.sampleWithoutReplacement(
            params.colors.filter(c => c !== targetColor), 1)[0];
          distractorShape = jsPsych.randomization.sampleWithoutReplacement(
            params.shapes.filter(s => s !== targetShape), 1)[0];
        }
        
        objects.push({
          x: positions[i].x,
          y: positions[i].y,
          size: getObjectSize(),
          color: distractorColor,
          shape: distractorShape,
          isTarget: false
        });
      }
    }

    // Draw search display based on view condition
    function drawSearchDisplay(ctx, viewCondition) {
      ctx.clearRect(0, 0, params.screenWidth, params.screenHeight);
      
      if (viewCondition !== 'fullscreen') {
        // Clip to window area
        const searchWindow = document.getElementById('search-window');
        const windowRect = searchWindow.getBoundingClientRect();
        
        ctx.save();
        ctx.beginPath();
        ctx.rect(windowRect.left, windowRect.top, windowRect.width, windowRect.height);
        ctx.clip();
      }
      
      // Draw all objects
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        drawObject(ctx, obj.x, obj.y, obj.size, obj.color, obj.shape);
      }
      
      if (viewCondition !== 'fullscreen') {
        ctx.restore();
      }
    }

    // Draw an object on the canvas
    function drawObject(ctx, x, y, size, color, shape) {
      ctx.fillStyle = color;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      
      switch (shape) {
        case 'circle':
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          break;
        case 'triangle':
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x + size / 2, y + size / 2);
          ctx.lineTo(x - size / 2, y + size / 2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
        case 'square':
          ctx.beginPath();
          ctx.rect(x - size / 2, y - size / 2, size, size);
          ctx.fill();
          ctx.stroke();
          break;
        case 'diamond':
          ctx.beginPath();
          ctx.moveTo(x, y - size / 2);
          ctx.lineTo(x + size / 2, y);
          ctx.lineTo(x, y + size / 2);
          ctx.lineTo(x - size / 2, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
      }
    }

    // Feedback for visual search task
    const searchFeedback = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Get the last visual search task data specifically
        const searchData = jsPsych.data.get().filter({task: 'visual_search'}).last(1).values()[0];
        const correct = searchData.correct;
        
        const feedbackColor = correct ? 'text-green-600' : 'text-red-600';
        const feedbackBg = correct ? 'bg-green-50' : 'bg-red-50';
        const feedbackBorder = correct ? 'border-green-200' : 'border-red-200';
        const feedbackIcon = correct ? 
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>' :
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path>';
        
        return `
          <div class="min-h-screen flex items-center justify-center p-6">
            <div class="bg-white rounded-xl shadow-lg p-8 text-center max-w-md w-full">
              <div class="${feedbackBg} ${feedbackBorder} border-2 rounded-lg p-8">
                <div class="flex justify-center mb-4">
                  <svg class="w-16 h-16 ${feedbackColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    ${feedbackIcon}
                  </svg>
                </div>
                <h1 class="text-3xl font-bold ${feedbackColor}">${correct ? '正解!' : '不正解'}</h1>
              </div>
            </div>
          </div>
        `;
      },
      data: {
        task: 'search_feedback'
      },
      choices: "NO_KEYS",
      trial_duration: 1000
    };

    // Feedback for memory task
    const memoryFeedback = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Get the last memory task data specifically
        const memoryData = jsPsych.data.get().filter({task: 'memory_recall'}).last(1).values()[0];
        const correct = memoryData.memory_correct === 1;
        
        const feedbackColor = correct ? 'text-green-600' : 'text-red-600';
        const feedbackBg = correct ? 'bg-green-50' : 'bg-red-50';
        const feedbackBorder = correct ? 'border-green-200' : 'border-red-200';
        const buttonColor = correct ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700';
        const feedbackIcon = correct ? 
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>' :
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path>';
        
        return `
          <div class="min-h-screen flex items-center justify-center p-6">
            <div class="bg-white rounded-xl shadow-lg p-8 text-center max-w-md w-full">
              <div class="${feedbackBg} ${feedbackBorder} border-2 rounded-lg p-6 mb-6">
                <div class="flex justify-center mb-4">
                  <svg class="w-16 h-16 ${feedbackColor}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    ${feedbackIcon}
                  </svg>
                </div>
                <h1 class="text-3xl font-bold ${feedbackColor} mb-4">${correct ? '正解!' : '不正解'}</h1>
                <p class="text-gray-600">下のボタンをクリックして次に進みます</p>
              </div>
              <button id="memory-feedback-next-btn" class="${buttonColor} text-white font-semibold py-3 px-8 rounded-lg transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2">
                次へ
              </button>
            </div>
          </div>
        `;
      },
      data: {
        task: 'memory_feedback'
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('memory-feedback-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // End screen with overall score
    const endScreen = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // Calculate overall accuracy for visual search
        const searchData = jsPsych.data.get().filter({task: 'visual_search'});
        const correctSearches = searchData.filter({correct: true}).count();
        const searchAccuracy = Math.round((correctSearches / searchData.count()) * 100);
        
        // Calculate overall memory task accuracy if applicable
        let memoryAccuracyText = '';
        const memoryScores = jsPsych.data.get().select('memory_correct').values;
        
        if (memoryScores && memoryScores.length > 0) {
          // Filter out undefined values and calculate mean
          const filteredScores = memoryScores.filter(score => score !== undefined);
          if (filteredScores.length > 0) {
            const avgMemoryAccuracy = filteredScores.reduce((a, b) => a + b, 0) / filteredScores.length;
            const memoryAccuracy = Math.round(avgMemoryAccuracy * 100);
            memoryAccuracyText = `<p>記憶課題の正答率: ${memoryAccuracy}%</p>`;
          }
        }
        
        return `
          <div class="min-h-screen bg-gradient-to-br from-emerald-50 to-teal-100 flex items-center justify-center p-6">
            <div class="bg-white rounded-xl shadow-lg p-8 max-w-2xl w-full text-center">
              <div class="mb-8">
                <div class="inline-flex items-center justify-center w-20 h-20 bg-emerald-100 rounded-full mb-6">
                  <svg class="w-10 h-10 text-emerald-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>
                </div>
                <h1 class="text-4xl font-bold text-gray-800 mb-4">実験終了</h1>
                <p class="text-lg text-gray-600 mb-8">実験にご参加いただき、誠にありがとうございました。</p>
              </div>
              
              <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div class="bg-gradient-to-r from-blue-50 to-blue-100 border border-blue-200 rounded-lg p-6">
                  <div class="flex items-center justify-center mb-3">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                      <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                      </svg>
                    </div>
                  </div>
                  <h3 class="text-lg font-semibold text-blue-800 mb-2">探索課題</h3>
                  <p class="text-2xl font-bold text-blue-600">${searchAccuracy}%</p>
                  <p class="text-sm text-blue-700">正答率</p>
                </div>
                
                ${memoryScores && memoryScores.length > 0 ? `
                <div class="bg-gradient-to-r from-purple-50 to-purple-100 border border-purple-200 rounded-lg p-6">
                  <div class="flex items-center justify-center mb-3">
                    <div class="w-8 h-8 bg-purple-500 rounded-full flex items-center justify-center">
                      <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                      </svg>
                    </div>
                  </div>
                  <h3 class="text-lg font-semibold text-purple-800 mb-2">記憶課題</h3>
                  <p class="text-2xl font-bold text-purple-600">${Math.round((memoryScores.filter(score => score !== undefined).reduce((a, b) => a + b, 0) / memoryScores.filter(score => score !== undefined).length) * 100)}%</p>
                  <p class="text-sm text-purple-700">正答率</p>
                </div>
                ` : ''}
              </div>
              
              <div class="bg-amber-50 border border-amber-200 rounded-lg p-6 mb-8">
                <div class="flex items-center justify-center mb-4">
                  <div class="w-10 h-10 bg-amber-400 rounded-full flex items-center justify-center">
                    <span class="text-xl">🎉</span>
                  </div>
                </div>
                <p class="text-amber-800 font-medium">
                  お疲れさまでした！<br>
                  ご協力いただいたデータは研究に活用させていただきます。
                </p>
              </div>
              
              <button id="end-screen-next-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-4 px-8 rounded-lg text-xl transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-emerald-500 focus:ring-offset-2 shadow-lg">
                実験を終了する
              </button>
            </div>
          </div>
        `;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the End button
        const nextBtn = document.getElementById('end-screen-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };

    // Practice completion choice screen
    const practiceCompletionChoice = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = `
          <div class="min-h-screen bg-gradient-to-br from-indigo-50 to-purple-100 flex items-center justify-center p-6">
            <div class="bg-white rounded-xl shadow-lg p-8 max-w-2xl w-full text-center">
              <div class="mb-8">
                <div class="inline-flex items-center justify-center w-16 h-16 bg-indigo-100 rounded-lg mb-4">
                  <svg class="w-8 h-8 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>
                </div>
                <h1 class="text-3xl font-bold text-gray-800 mb-4">練習完了</h1>
                <p class="text-lg text-gray-600 mb-6">9回の練習が完了しました。お疲れさまでした！</p>
              </div>
              
              <div class="bg-gray-50 border border-gray-200 rounded-lg p-6 mb-8">
                <p class="text-gray-700 text-lg font-medium">操作に慣れましたか？以下から選択してください：</p>
              </div>
              
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <button id="practice-again-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-4 px-6 rounded-lg transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 flex items-center justify-center space-x-3">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                  </svg>
                  <span>もう一度練習する</span>
                </button>
                
                <button id="proceed-main-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-4 px-6 rounded-lg transition duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 flex items-center justify-center space-x-3">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path>
                  </svg>
                  <span>本番へ進む</span>
                </button>
              </div>
              
              <div class="mt-8 bg-blue-50 border border-blue-200 rounded-lg p-4">
                <p class="text-blue-700 text-sm">
                  <strong>ヒント：</strong> 操作に不安がある場合は、もう一度練習することをお勧めします。
                </p>
              </div>
            </div>
          </div>
        `;
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        const practiceAgainBtn = document.getElementById('practice-again-btn');
        const proceedMainBtn = document.getElementById('proceed-main-btn');
        
        practiceAgainBtn.addEventListener('click', function() {
          jsPsych.finishTrial({
            choice: 'practice_again'
          });
        });
        
        proceedMainBtn.addEventListener('click', function() {
          jsPsych.finishTrial({
            choice: 'proceed_main'
          });
        });
      }
    };

    // Main experiment start notice
    const mainExperimentStart = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div style="max-width: 600px; margin: 0 auto; padding: 20px; text-align: center;">
          <h1>本番開始</h1>
          <p style="font-size: 18px; margin: 20px 0;">ここから本番です</p>
          <p style="font-size: 16px; margin: 20px 0;">
            練習で体験した内容と同じ課題を行います。<br>
            集中して取り組んでください。
          </p>
          <p style="font-size: 16px; margin: 20px 0;">
            <strong>下の「次へ」ボタンをクリックして本番を開始してください。</strong>
          </p>
          <div style="margin: 20px 0;">
            <button id="main-experiment-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">次へ</button>
          </div>
        </div>
      `,
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('main-experiment-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };
    
    // Midpoint message
    const midpointMessage = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <h1>半分終了</h1>
        <p>お疲れさまでした。ここで半分終了です。</p>
        <p>ここからは記憶についての課題を追加します。</p>
        <p><strong>下の「次へ」ボタンをクリックして次に進みます。</strong></p>
        <div style="margin: 20px 0;">
          <button id="midpoint-next-btn" style="padding: 12px 24px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">次へ</button>
        </div>
      `,
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('midpoint-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
      }
    };
    
    // WM task explanation (updated according to wireframe ②)
    const wmTaskExplanation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        let html = '<div style="max-width: 800px; margin: 0 auto; padding: 20px; font-family: \'Noto Sans JP\', \'ヒラギノ角ゴ Pro\', \'Hiragino Kaku Gothic Pro\', \'メイリオ\', Meiryo, sans-serif; line-height: 1.8; background-color: #ffffff;">';
        
        // Title
        html += '<h1 style="text-align: center; color: #2c3e50; margin-bottom: 40px; font-size: 32px; font-weight: bold;">後半の実験について</h1>';
        
        // Memory task explanation
        html += '<div style="background-color: #fff3cd; border: 2px solid #ffc107; border-radius: 12px; padding: 25px; margin-bottom: 30px;">';
        html += '<h2 style="color: #856404; margin: 0 0 20px 0; font-size: 22px;">新しく追加される記憶課題</h2>';
        
        // Step-by-step explanation
        const memorySteps = [
          { 
            step: '1', 
            text: 'ターゲットが表示される前に、4×4のパネルが表示されます。',
            detail: 'パネルはランダムな3箇所に色がついているので、場所を記憶してください。'
          },
          { 
            step: '2', 
            text: 'そのまま、前半と同じ課題に取り組みます。',
            detail: '図形を探してクリックする作業は前半と全く同じです。'
          },
          { 
            step: '3', 
            text: 'その後、先ほど記憶したパネルの場所を回答します。',
            detail: '色のついていた位置をクリックで選択してください。'
          },
          { 
            step: '4', 
            text: 'これを何度も繰り返します。',
            detail: '記憶と視覚検索の両方に集中してください。'
          }
        ];
        
        memorySteps.forEach(step => {
          html += `<div style="background-color: #ffffff; border: 2px solid #e2e2e2; border-radius: 8px; padding: 20px; margin-bottom: 15px; display: flex; align-items: flex-start; gap: 15px;">`;
          html += `<div style="background-color: #856404; color: white; width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; font-size: 18px;">${step.step}</div>`;
          html += `<div style="flex: 1;">`;
          html += `<div style="font-size: 17px; color: #333; font-weight: bold; margin-bottom: 8px;">${step.text}</div>`;
          html += `<div style="font-size: 15px; color: #666; line-height: 1.6;">${step.detail}</div>`;
          html += `</div></div>`;
        });
        
        html += '</div>';
        
        // Visual example
        html += '<div style="background-color: #f8f9fa; border: 2px solid #dee2e6; border-radius: 12px; padding: 25px; margin-bottom: 30px;">';
        html += '<h3 style="color: #495057; margin: 0 0 20px 0; font-size: 20px; text-align: center;">4×4パネルの例</h3>';
        
        html += '<div style="display: flex; justify-content: center; align-items: center; gap: 30px; margin: 20px 0;">';
        
        // Memory grid example
        html += '<div style="text-align: center;">';
        html += '<div style="display: grid; grid-template-columns: repeat(4, 50px); gap: 3px; background-color: #ffffff; padding: 15px; border-radius: 8px; border: 2px solid #ddd; margin-bottom: 10px;">';
        
        // Create 4x4 grid example with 3 yellow cells
        for (let i = 0; i < 16; i++) {
          let bgColor = '#f8f9fa';
          if (i === 2) bgColor = '#f1c40f'; // Yellow
          if (i === 7) bgColor = '#f1c40f'; // Yellow
          if (i === 13) bgColor = '#f1c40f'; // Yellow
          
          html += `<div style="width: 50px; height: 50px; background-color: ${bgColor}; border: 2px solid #bdc3c7; border-radius: 5px;"></div>`;
        }
        
        html += '</div>';
        html += '<p style="font-size: 14px; color: #666; margin: 0;">色のついた3つの位置を覚えてください</p>';
        html += '</div>';
        
        html += '<div style="font-size: 24px; color: #666;">→</div>';
        
        // Arrow and explanation
        html += '<div style="text-align: center; max-width: 300px;">';
        html += '<div style="background-color: #e3f2fd; padding: 15px; border-radius: 8px; border: 2px solid #2196f3;">';
        html += '<p style="margin: 0; font-size: 16px; color: #1976d2; font-weight: bold;">視覚検索課題を実行</p>';
        html += '<p style="margin: 8px 0 0 0; font-size: 14px; color: #424242;">記憶した位置を頭に置きながら<br>図形を探してクリック</p>';
        html += '</div>';
        html += '</div>';
        
        html += '</div>';
        html += '</div>';
        
        // Important reminder
        html += '<div style="background-color: #f8d7da; border: 2px solid #f5c6cb; border-radius: 12px; padding: 20px; margin-bottom: 30px; text-align: center;">';
        html += '<h3 style="color: #721c24; margin: 0 0 15px 0; font-size: 20px;">重要なポイント</h3>';
        html += '<ul style="text-align: left; color: #721c24; font-size: 16px; margin: 0; padding-left: 20px;">';
        html += '<li style="margin-bottom: 8px;">記憶課題と視覚検索課題の両方に集中してください</li>';
        html += '<li style="margin-bottom: 8px;">できるだけ早く、正確に図形を見つけてクリックしてください</li>';
        html += '<li style="margin-bottom: 8px;">色がついた位置を正確に記憶し、後で思い出してください</li>';
        html += '</ul>';
        html += '</div>';
        
        // Continue button
        html += '<div style="text-align: center; margin-top: 40px;">';
        html += '<button id="wm-task-next-btn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 18px 45px; font-size: 20px; border-radius: 10px; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.2); transition: transform 0.2s; font-weight: bold;">後半を開始する</button>';
        html += '</div>';
        
        html += '</div>';
        
        return html;
      },
      choices: "NO_KEYS",
      on_load: function() {
        // Add click event listener to the Next button
        const nextBtn = document.getElementById('wm-task-next-btn');
        nextBtn.addEventListener('click', function() {
          jsPsych.finishTrial();
        });
        
        // Add hover effect to button
        nextBtn.addEventListener('mouseenter', function() {
          this.style.transform = 'translateY(-2px)';
        });
        
        nextBtn.addEventListener('mouseleave', function() {
          this.style.transform = 'translateY(0)';
        });
      }
    };

    // Practice trial variables - fixed order: fullscreen, window, scroll (repeated 3 times)
    const practiceTrialVariables = [
      // First set
      { viewCondition: 'fullscreen', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      { viewCondition: 'window', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      { viewCondition: 'scroll', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      // Second set
      { viewCondition: 'fullscreen', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      { viewCondition: 'window', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      { viewCondition: 'scroll', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      // Third set
      { viewCondition: 'fullscreen', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      { viewCondition: 'window', structure: 'structured', memoryLoad: 'without-memory', isPractice: true },
      { viewCondition: 'scroll', structure: 'structured', memoryLoad: 'without-memory', isPractice: true }
    ];

    // Create separate factorial designs for with-memory and without-memory conditions
    const viewAndStructureFactors = {
      viewCondition: ['window', 'scroll', 'fullscreen'],
      structure: ['structured', 'unstructured']
    };
    
    // First block without memory task
    const withoutMemoryDesign = jsPsych.randomization.factorial(viewAndStructureFactors, params.trialsPerCondition);
    withoutMemoryDesign.forEach(trial => {
      trial.memoryLoad = 'without-memory';
    });
    
    // Second block with memory task
    const withMemoryDesign = jsPsych.randomization.factorial(viewAndStructureFactors, params.trialsPerCondition);
    withMemoryDesign.forEach(trial => {
      trial.memoryLoad = 'with-memory';
    });
    
    // Build timeline procedure for a single trial
    const trialProcedure = {
      timeline: [
        visualSearchInstructions,
        // Memory task is only included for 'with-memory' condition
        {
          timeline: [memoryGridDisplay],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        blankScreen,
        showTarget,
        blankScreen,
        visualSearch,
        // Search feedback for 'with-memory' condition comes immediately after visual search
        {
          timeline: [searchFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        // Memory recall only for 'with-memory' condition
        {
          timeline: [memoryGridRecall],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          },
          data: {
            task: 'memory_recall'
          }
        },
        // Memory feedback only for 'with-memory' condition
        {
          timeline: [memoryFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'with-memory';
          }
        },
        // Search feedback for 'without-memory' condition comes at the end
        {
          timeline: [searchFeedback],
          conditional_function: function() {
            return jsPsych.timelineVariable('memoryLoad') === 'without-memory';
          }
        }
      ]
    };
    
    // Practice trial procedure (simplified version without memory tasks)
    const practiceTrialProcedure = {
      timeline: [
        visualSearchInstructions,
        blankScreen,
        showTarget,
        blankScreen,
        visualSearch,
        // Always show search feedback for practice (no memory component)
        searchFeedback
      ]
    };

    // Practice block procedure
    const practiceBlockProcedure = {
      ...practiceTrialProcedure,
      timeline_variables: practiceTrialVariables,
      randomize_order: false // Keep fixed order for practice
    };

    // Complete practice procedure with loop
    const practiceProcedure = {
      timeline: [
        practiceBlockProcedure,
        practiceCompletionChoice,
        {
          timeline: [practiceBlockProcedure],
          conditional_function: function() {
            // Check if user chose to practice again
            const lastChoice = jsPsych.data.get().last(1).values()[0];
            return lastChoice.choice === 'practice_again';
          }
        }
      ],
      loop_function: function() {
        // Check if user chose to practice again
        const lastChoice = jsPsych.data.get().last(1).values()[0];
        return lastChoice.choice === 'practice_again';
      }
    };

    // First block (without memory)
    const firstBlockProcedure = {
      ...trialProcedure,
      timeline_variables: withoutMemoryDesign,
      randomize_order: true
    };
    
    // Second block (with memory)
    const secondBlockProcedure = {
      ...trialProcedure,
      timeline_variables: withMemoryDesign,
      randomize_order: true
    };

    // Full experiment timeline
    const timeline = [
      welcome,
      informedConsent,
      demographics,
      experimentInstructions,
      practiceExplanation,
      practiceProcedure,
      mainExperimentStart,
      firstBlockProcedure,
      midpointMessage,
      wmTaskExplanation,
      secondBlockProcedure,
      endScreen
    ];

    // Run the experiment using jsPsych v7 API (upgraded from v6.3.1)
    jsPsych.run(timeline);
  </script>
</body>
</html>
